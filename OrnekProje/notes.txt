Derleme : c# kodlarını assembly tarzı sadece bilgisayarın anlayabileceği dillere çevirme işlemidir.

Beşeri seviyede algılanabilen dillere yüksek seviyeli diller denir. c# orta seviye bir dildir. 

çok yüksek seviyeli diller ;

Visual Basic , VB.Net , Foxpro , Access...

Yüksek seviyeli diller ;

Pascal ,  Basic , Fortran...

Orta seviyeli diller ;

C , C++ , C# , Java , ADA...

Düşük seviyeli diller ; 

assembly...

Makine dilleri ;

1 veya 0 lardan oluşur.


C# ile neler yapılabilir,

1- Web uygulamaları,
2- Mobil uygulamaları,
3- Web Servisleri,
4- Servis Mimarileri,
5- consol uygulamaları,
6- .dll uzantılı dosyalar,
7- Windows form uygulamaları,
8- oyunlar,
9- ERP, Muhasebe, Multi Media, İstatistik, Güvenlik Yazılımları...


.net microsoft tarafından yazılım geliştiriciler için geliştirdiği teknolojileri sunduğu bir çatıdır.
microsoft işletim sistemleri için de teknoloji sunarlar ancak bu teknoloji son kullanıcılar içindir.

.net çatısı altındaki paket yayınları şuan .net 8.0 paketi yayında.

.net bir developer'a lazım olabilecek bütün platformlar vardır. mobil, gaming, desktop.....

.net framework ile .net core arasındaki fark nedir?

.net framework da her platformda geliştirme yapabiliyoruz ancak sadece windosw işletim sistemine çalıştırabiliyoruz.
.net core da ise her platformda geliştime yapabiliyoruz ve her platformda da çalıştırabiliyoruz.

.net core modüler bir yapıya sahiptir.
.net core ilk sürümü .net 5.0 dır.

C# .net core çatısı altında yayınlanan teknolojilerden birisidir.

derleme nedir ? 

bir uygulama dili derlenen bir dil ise önce derlenir sonra çalıştırılır. (derlemek=makine diline çevirmek)

derlenen diller;

C , C++ , C#

yorumlanan diller ;

Python, JsvsScript, Ruby, PHP, Perl

Derleme sonucu ilgili dosyada 2 şekilde dosya oluşur. 

1- .exe uzantılı dosya 
2- .dll uzantılı dosya
bu dosyalar derleme sonucu oluşan ve son kullanıcıya ulaşan dosya uzantılarıdır.


Microsoft Visual Studio ;

microsoft tarafından geliştirilmiş ve .net mimarilerinin tamamını kodlayabileceğimiz bir platformdur.

en çok kullanılanlar ;

debug       : kontrollü çalıştırma,
nuGet       : peket yükleme,
ErrorList   : Hata Listeleme

proje oluşturma nasıl yapılır.

proje      : içerisinde amaca uygun çözüm geliştirilen operasyonların yürütüldüğü bir bölümdür.
solution   : içerisinde bir veye birden fazla proje barındırabilen evrensel bir kümedir.


gerçek hayatta bir uyglama yazarken bu uygulama bir proje değil bir solution dur. 
bu solution birden fazla projenin birleşimi olabilir.


Visual Studio Code ile proje oluşturma ve derleme;

- create new project ile proje başlatılır.
- en basit uygulama console uygulamasıdır.
- solution name ile project name aynı olmak zorunda değildir.
- bir solution a birden falz proje eklemek istersek solution üzerine sağ tık yaparak Add/New project diyebiliriz.
- Derleme işleminden sonra oluşan bin klasörü altında yer alır.
- derleme sonucu : .deps.json, .dll, .pdb, .runtimeconfig.json uzantılı dosyalar oluşur.
- .net 6.0 ve .net 7.0 da da aynı dosya uzantıları mevcuttur.



Visual Studio Code , Visual Studio ya nazaran daha hızlı kod yazmaya yarar.

VS Code avantajları , 

- kendinde dahili bir komut satırı barındırır.
- komut satırında CLI adını verdiğimiz herhangi bir arayüzü olmayan bir asistan mevcuttur.

en yaygın kullanılan CLI komutlar:

ls : mevcut dizindeki dosya ve dizinleri listeler,
cd : dizinleri değiştirmemize yarar. 
pwd : şuanki dizinin yolunu gösterir.
mkdir : yeni bir dizin oluşturur.
touch : yeni bir dosya oluşturur veya oluşturulan dosyanın tarihinü günceller.

cp : dosyaları koplayalar,
mv : dosyaları taşır veya yeniden isimlendirir.
rm : dosyaları veya dizinleri siler 
cat: dosyaları birleştirir ve içeriklerini görüntüler
more veya less: uzun metin dosyalarını sayfa sayfa görüntüler.

- dizin ve dosya işlemleri :
grep : belirli bir metini dosya içerisinde arar.
find : dizinler arasında dosya arar.
chmod : dosya ve dizinlerin izinlerini değiştirir.
chowm : dosya ve dizinlerin sahiplerini değiştirir.

- ağ işlemleri : 
ping : bir IP adresini veya alan adını belirtilen sayıda paket gönderir ve yanıtları görüntüler,
ifconfig ve ip : ağ arayüzünü ve IP bilgilerini görüntüler,
ssh : uzak sunuculara güvenli bir şekilde başlanmamızı sağlar,

- paket yönetimi : 
apt-get : debian tabanlı işlemler için paketleri yinetir,
yum : red hat tabanlı işlemler için paketleri yinetir,
brew : macos tabanlı işlemler için paketleri yinetir,

-sistem bilgileri :
top veya htop : sistem kaynaklarını ve çalışan işlemleri görüntüler.
df : disk kullanımını gösterir.
free : bellek kullanımını gösterir.
uname : sistem bilgilerini gösterir.

- kullanıcı ve izinler ;
who veya w:aktif kullanıcıları ve oturum bilgilerini görüntüler,
useradd : kullanıcı ekler,
userdel : kullanıcı siler,
passwd : kullanıcı parolasını değiştirir.
sudo : yönetici veya süper kullanıcı haklarıyla komut çalıştırır.

- metin işlemleri :
echo : metin çıktısı üretir.
grep : metin içerisindeki desen eşleştirmeleri yapar.
sed : metin düzenlemesi yapar.


dotnet CLI ile proje oluşturma:

dotnet CLI ile proje oluştururken içerisinde bulunduğumuz komuta dikkat etmemiz gerekir.
dotnet CLI yı çağırmak için terminal ekranına 'dotnet' yazmamız yeterlidir.
dotnet --help ile dotnet üzerinden yapabileceklerimizi listeleyebiliriz.

uygulama başlatmak için ;

dotnet new (buraya uygulama tipini yazıyoruz) --name (buraya uygulama ismini yazıyoruz)

başlattığımız uygulamayı derleyebilmek için ;

dotnet build.


// dotnet CLI nedir?

Visual Studio idesinde kendi yaptığımız işlemleri komut satırı ile yapabilmek için CLI isimli asistandan aracılı ile yapabiliriz.


// dotnet CLI komutları nelerdir?

1- help : dotnet CLI tarafından desteklenen komutlar hakkında ayrıntılı bilgi veren kokmuttur. ( dotnet help)

2- new  : dotnet CLI üzerinden proje oluşturmaya yardımcı olan komuttur. (dotnet new (proje tipi) --name (proje ismi))

not : sadece dotnet new yazıp enter tuşuna bastığımızda hangi proje tiplerini oluşturabileceğimiz konusunda CLI bize yardımcı olur.

not: aynı isimde farklı bir dosya olmasından kaynaklı olarak oluşacak hatalarda (dotnet new (proje tipi) --name (proje ismi)) --force
şeklinde satırın sonuna force keyword unu kullanırsak hata almadan işlemi yapabiliriz.

3- restore : proje sürecinde referans edilen yahut referansı kaldırılan paketlerin restorasyonunu sağlar. (dotnet restore)

referans mantığı nedir ? 

bir yazılım geliştirme sürecinde işlemleri / iş mantıklarını genellikle kah kendimiz tarafından kah başkaları tarafından (ki genelde başkaları tarfından)
önceden yazılmış kütüphanelerin desteğini alarak çözmeye referans mantığı denir.

restore edilen paketler nuGet ten gelir.

4- build : projeyi ilk önce restore eder ve sonrasında derler. sonuç olarak .exe ve .dll çıktıları verir. 
bu .dll ve .exe uzantılı dosyalar /bin/Debug/net7.0 dizininde görüntülenir.

not : proje derlemeden önce muhakkak restore edilir.


5- publish : projeyi derleyerek yayınlanabilir dosyaların oluşmasını sağlar. çıktılar /bin/Debug/net7.0/publish dizininde bulunur.

publish klasörü altında : 

.dll,
.deps.json,
.runtimeconfig.json,
.uygulama bağlantılarının .dll dosyaları

bulunur.

not : uygulamaya ait algoritmaları yayınlamak istemiyor olabiliriz, böyle bir durumda publish komutu bize yardımcı olur.
not2: publish dosyalarında herhangi bir güncelleme yapılamaz, yapılan değişikliklerden sonra tekrar oluşturmak gerekir. çıktı almak gibi...

6- run : uygulamayı derler ve ayağa kaldırır. (dotnet run ) 

not : dotnet run --no-build uyulamayı derlemeden ayağa kaldırır.


// proje modifikasyon komutları:

proje seviyesinde işlem yapmamızı ve referans ekleyip çıkarmamızı sağlayan komutlardır.

paket / kütüphane : nuGet havuzundan gelir,
referans          : önceden yazılmış .dll uzantılı dosyalardır.
.exe uzantısı     : yazdığımız uygulamayı bir insan kullanacaksa bu uzantıda olur.
.dll uzantısı     : yazdığımız uygulamayı bir yazılım kullanacaksa bu uzantıda olur.

1- add package : uygulamaya nuGet'den paket / kütüphane yüklememizi sağlar.

dotnet add package (paket ismi)  / ile terminalden paket yükleyebiliriz.

2- add referance : uygulamaya fiziksel bir .dll uzantılı dosya referans etmemizi sağlar.

diyelimki solution unumuzda birden fazla uygulama var ve bu uygulamalar birbirlerini referans etmek zorundalar.
örneğin veri tabanı işlemlerini bir uygulama aracılığı ile yapıyoruz , iş mantığını / ana olayların cereyan ettiği olayları 
başka bir uygulama ile yapıyoruz. ana olayların cerayan ettiği uygulamaya veri tabanı işlemlerinin yapıldığı uygulamayı
referans etmek zorundayız.

dotnet add referance (referasn edilen ana dosya).csproj referance (referans eden ufak dosya).csproj

3- remove package : uygulamada add package ile yüklediğimiz paketleri/kütüphaneleri silmeye yarar.

dotnet remove package ( package ismi)

4- remove referance : uygulamaya referans edilmiş dll dosyalarını kaldırmaya yarar.

dotnet remove referance (referans ismi)

list referance : uygulamda referans edilen tüm paketleri / kütüphaneleri listeler.

dotnet list referance 

n adet uygulamanın olduğu bir solutionda çalıştığımızı varsayalım . 
hangi uygulamanın hangi paketlerin/kütüphanelerin referans edildiğini kodlara bakmadan 
bu yöntemle öğrenebiliriz

// programlamaya başlarken temel ilkeler:

yeni çıkan her dil bir gelenek ve bir kabul ile yola çıkar. bunlara ilke diyoruz.

ilke-1 : don't repeat your self 

bir kod inşa edilirken kullandığımız dile ait bütün özellikleri bildiğimizi varsayalım ,
aynı kod parçasını birden fazla yerde aynı yöntemle kullanırsak bu 1.ilkeye aykırı bir davranış olur. 
günün birinde uygulamada tekrar eden kod parçalarında değişiklik yapmak istersek tek tek bütün kopyalarını bulmamız gerekir.
bir algoritmayı öğrenerek birden fazla problemde aynı algoritmayı kullanmak 1.ilkeye uymaz.

tecrübeden faydalanmak yaratıcılığı öldürür.

ilke-2 : anlamlı isimlendirme,

isimlendirme yaptığımızda anlamlı ve çağırışım yapan isim vermemiz gerekir.

// main fonkiyonu nedir ? 

bir uygulama içerisinde muhakkak olması gereken bir fonksiyondur.
program.cs dosyası uygulamanın başlangıç dosyasıdır ve başlangıç kodları burada bulunur.

not : .cs uzantılı dosyalar c# dilinde yazılmış dosyalarıdır.

başlangıç kodlarından kastımız nedir ?

uygulama ayağa kalktığında işletim sistemi ile iletişim kurabilecek fonksiyonun 
ve bu fonksiyon içerisinde başlangıca dair komutları barındıracak bir yapıdır.

not : işletim sistemi ile sadece program.cs dosyası içerisindeki main fonksiyonu iletişim kurabilir.

main fonksiyonu kuralları : 

1- main fonksiyonu uyglamaya özgüdür ve her projede yanlızca 1 adet olur.
2- aynı uygulama içerisinde 2.bi main fonksiyonu yoktur.


işletim sisteminden parametre ile console'a değer yazdırabiliriz.

static void Main(string[] args)
{
    Console.WriteLine("Hello World!");
    Console.WriteLine(args[0]);
    Console.WriteLine(args[1])
}

terminalden dotnet run sedat mengü yazdığımızda çıktı ekranına ;

Hello World!
sedat
mengü

// top level statement nedir ? 

C# 9.0 ile gelmiştir.

// yorum satırları ve region özelliği : 

// tek satırlık yorumlarda kullanılır.

/*
çok
satırlık
yorumlarda
kullanılır
*/

region : kod dosyasını kategorik hale getirebilemizi sağlayan bir ön işlemci komutudur. 

developerların yazdıkları kodların daha net görebilmelerine yardımcı olur.

#region A operasyonu
    Console.WriteLine("Hello, World!");
    Console.WriteLine(typeof(char).IsPrimitive);
    Console.WriteLine(typeof(sbyte).IsPrimitive);
    Console.WriteLine(typeof(byte).IsPrimitive);
    Console.WriteLine(typeof(short).IsPrimitive);
    Console.WriteLine(typeof(ushort).IsPrimitive);
    Console.WriteLine(typeof(int).IsPrimitive);
    Console.WriteLine(typeof(uint).IsPrimitive);
    Console.WriteLine(typeof(long).IsPrimitive);
    Console.WriteLine(typeof(ulong).IsPrimitive);
    Console.WriteLine(typeof(float).IsPrimitive);
    Console.WriteLine(typeof(double).IsPrimitive);
    Console.WriteLine(typeof(decimal).IsPrimitive);
#endregion

#region A operasyonu

// todo özelliği : (editorun sağlamış olduğu bir özelliktir.)
kodun içerisinde yazılan notlara bir liste aracılığı ile ulaşmaya yarar. 

todo listesi genelde takım çalışmalarında hangi takım çalışanının müdahale etmesi istenirse o kişiye atıfra bulunulmak için kullanışlıdır.

todo listelerine erişmek için;

vs de görünüm/görevler penceresinden ulaşabilirz.
vscode da ise sol taraftaki çubukta 'source control' alanı içerisinden ulaşabiliriz.



// debuging :

projenin her aşamasında en çok kullandığımız özelliklerdendir. platform ve teknoloji farketmeksizin her noktada kullanılır.

brekapoint kavramı ;

debug işleminde hassas olan satıra koyduğumuz ve debuging esnasında durduğumuz noktadır. 
debug modda 1 adım ilerlemek için F10 tuşuna basaır. her basışımız uygulamanın bir adım daha ilerlemesini sağlar.

F5 ile debug modu salmış oluruz ve uygulama sona kadar gitmiş olur.

watch penceresi nedi ? 

debug modda çalıştırma esnasında bazı değişikliklerin değerlerini izlemek isteyebiliriz. 
debug çalışırken izlemek istediğimiz değişkenin üzerine tıklayarak 'izleme ekle' seçeneğini seçerek 
watch penresesine eklemiş oluruz.

peki debuguz uygulamayı çalıştırmak nasıl olur?

debug zaman ve performasn açısından maliyetli bir yoldur. genelde projemizden emin olduğumuz durumlarda debugsuz çalıştırabiliriz.



// değişkenler nelerdir ?

değişkene neden ihtiyaç duyarız.

amaç : elimizdeki verileri doğru yazılımlar ile doğru bir şekilde işleyerek doğru sonuçları elde etmektir.

yazılım herhangi bir veri tutmaz , işlem gerçekleştiği esnada veriler RAM'da tutulurlar , oradan alınır, kullanılır , ve geri yerine konur...

işte bu noktada değişkenleri RAM'de tutabilmek için değişkenleri kullanılırız. 

veri tabanındaki verileri direkt olarak işleyemeyiz, değişken yardımı ile RAM'den alıp değiştirip geri yerine koyarız.

önemli not: iş yapıyorsak RAM'de çalışmalıyız.

tanım : yazılımda işlenecek veriyi yazılım adına RAM'e yerleştirebilmek için biz developerlar değişkenleri kullanırız.

value type ve primitive type nedir ?

C# dili yapısı gereği RAM'e yerleştireceğimiz veri türünü bilmek ister ki ona göre bir alan tahsisinde bulunsun.

. bir değişkenle RAM'de alan tahsisinde bulunulduğunda buna 'değer türlü değişken' ( value type) deriz. yaş,boy,isim,trih vs...
. birden fazla farklı tipte değişken barındırabilen yapılara 'referans türlü değişken' deriz.

ad : "ali"; -- değer türlü değişken
soyad:"uzun"; --değer türlü değişken
yas=23; --değer türlü değişken
kanGrubu='a' -- değer türlü değişken

yukarıdaki bilgilerin tamamı paket olarak da referans türlü değişken olarak tanımlanır.

tanım : sadece bir tür değer tutan değişkenlere değer türlü değişken denirken, birden faza değişik türde değişken tutabilen türlere referans türlü değişken denir.

primitive type : ham veri , türetilmemiş veri anlamında kullanılır ve en ilkel türdür. (byte)

not : RAM'de değişken için alan tahsis edileceği zaman değişkenin türündne hareket edilir ve hangi türde değişken tanımlandıysa o türde değişken barındırılır.
string ile tahsis edilen alana double türünde bir veri barındıramazsınız , veya char türünde bir alan tahsisinde bulunduysanız int türünde bir değer barındıramazsınız. barındırtmazlar :)

veri türleri :

bool : true veya false tutabilir.   (1 bit )

char : tek karakter tutabilir.   (16 bit )

sbyte : -128 ile +127 arasındaki değerler tutabilir.   (8 bit )

byte : 0 ile +255 arasındaki değerler tutabilir.   (8 bit )

short : -32768 ile +32767 arasındaki değerler tutabilir.   (16 bit )

ushort : 0 ile 65535 arasındaki değerler tutabilir.   (16 bit )

int : -2147483648 ile +2147483647 arasındaki değerler tutabilir.   (32 bit )

uint : 0 ile +4294697295 arasındaki değerler tutabilir.   (322 bit )

long : -9233372036854775808 ile +9233372036854775807 arasındaki değerler tutabilir.   (64 bit )

ulong : 0 ile +18446744073709551615 arasındaki değerler tutabilir.   (64 bit )

float : +- 1.5 x 10(-45) ile +-3.4x10(38) arasındaki değerler tutabilir.   (32 bit )

double : +- 5x10(-324) ile +-1.7x10(308) arasındaki değerler tutabilir.   (64 bit )

decimal : +-1.5x10(-28) ile +-7.9x10(28) arasındaki değerler tutabilir.   (128 bit )

string : metinsel ifadeleri tuttuğumuz değişken türüdür ve referans tiplidir.


yukardaki türlerden sadece 'decimal' primitive değildir , geri kalan türlerin tamamı primitive dir.

bir türün primitve olup olmadığını nasıl kontrol edebiliriz.


Console.WriteLine(typeof(bool).IsPrimitive);
Console.WriteLine(typeof(char).IsPrimitive);
Console.WriteLine(typeof(sbyte).IsPrimitive);
Console.WriteLine(typeof(byte).IsPrimitive);
Console.WriteLine(typeof(short).IsPrimitive);
Console.WriteLine(typeof(ushort).IsPrimitive);
Console.WriteLine(typeof(int).IsPrimitive);
Console.WriteLine(typeof(uint).IsPrimitive);
Console.WriteLine(typeof(long).IsPrimitive);
Console.WriteLine(typeof(ulong).IsPrimitive);
Console.WriteLine(typeof(float).IsPrimitive);
Console.WriteLine(typeof(double).IsPrimitive);
Console.WriteLine(typeof(decimal).IsPrimitive);

örnek : 1000 değerini short , ushort , int , uint , long , ulong , float , double , decimal türlerinin tamamı ile tutabiliriz.
ancak yer proje optimizasyonu için en makul aralık olan short veya ushort u kullanmamız gerekir.

// C# dilinin temel kuralları : 

1- bütün kodlar main fonksiyonu içerisine yazılır.
2- { } bu yapı scope olarak değerlendiril (faliyet alanı)
3- C# BÜYÜK ve küçük harf duyarlılığna sahiptir. "ahmet","Ahmet","AhMet","AHMET" tamamen ayrı şeklerdir.
4- C# dili tip güvenliği olan bir dildir. 

değişken tanımlama;

degisken_turu degisken_adi;

bu şekilde ilk yazılacak olan değişkenin türüdür 2 yazılacak olan değişkenin anlamlı ismidir. (anlamlı olması 2.ilke)

örnek:

string adi;  --> bu şekilde RAM'de "adi" isminde string bir alan rezervasyonu yapılmış oldu. 
int yas ; --> bu şekilde RAM'de "yas" isminde integer bir alan rezervasyonu yapılmış oldu. 

ram yapısı : 

stack ve heap ram da kullandıığımız 2 alanın adıdır.

stack : içerisinde değer türlü değişkenlerin;

değişken türünün , 
değişken adının,
değişken değerininin,
metot/fonksiyon isimlerinin,

tutulduğu bir bölümdür.

heap : nesnelerin tutulduğu bölümdür.

not : stack içerisinde tutualn değişken ismine nadiren de olsa 'referans' dendiğini görebilirsiniz.
not : stack alanıda değişkene herhangi bir değer ataması yapılamasa dahi yer tahsisi yapılır.
not : metotların/fonksiyonların bellek adresleri de stack de tutulur.

metotları / fonksiyonları çağırmak üzere oluşturuyoruz ve bu metotlar/fonksiyonlar isim üzerinden çağırırız ve bu isimde denk gelen adres stack alanında tutulur.


değişken tanımlana kuralları:

değişken isimleri ilerleyen süreçte developer açısından karışıklığa mahal vermemek için anlanlı olmalıdır.
değişken isimleri . ' , gibi özel karakterler barındırmamalıdır. _ istisnadır.

1sayi olmaz , sayi1 olabilir.
ad? olmaz , ad olabilir,
stok.adedi olmaz , stok_adedi olabilir.

not : aynı scope içerisinde aynı isimde birden fazla değer tanımlanamaz.

isimlendimre gelenekleri ;

1- snace_case ; tük hrafler küçüktür ve kelimelerin arasına _ konur.

. kullanici_adi;
. isim_soyisim;
. personel_giderleri;

2- Pascal Name : her kelimenin ilk harfi büyük yazılır. klaltmalar özellikler büyük harf ile yazılır.

. AdSoyad;
. TcKimlikNo;
. Satislar;
. DogumTarihi;
. InOut = IO,
. InOutStream = IOStream;

3- camelCase : sadece ile kelimenin ilk harfi küçük yazılır, takip eden kelimelerin ilk harfleri her zaman büyük yazılır.

. satisDurumu;
. personeAdi;
. orderId;
. userNAme;
. userNAmePassword;

değişken isimlerinde @ operatörü : 

string x şeklinde bir değişken tanımlayabildiğimiz gibi string @x şeklinde de tanımlama yapabiliriz. 
ancak ahm@t gibi @ karakteri ismin ortasına kullanılırsa özel karaktere girer ve kabul edilmez.

static , for , if , string , int gibi programa özgü kelimeleri @ ilavesi ile değişken ismi olarak kullanabilirz.

string @string ,
int @int , 
double @double , 
string @static vb.

tanılanmış değişkene değer atama : 

int x ; şekilde herhangi bir değer ataması yapmadan da değişken tanımlayabildiğimiz gibi int x=5; gibi tanımlanmış değişkenlere de tekrardan değer atayabiliriz.

burada dikkat edilmesi gereken şey, bir değere en son atanan değer geçerlidir.

değişeken değer atama kuralları ;

değer türleri : 

1- metinsel değerler ; string keywordu ile tutulur, "..." içerisine yazılmalıdır. "gencay" , "12345678901" vb.

not : bir sayısal ifade "..." arasında metinsel bir biçimde tutuluyor ise herahngi bir matematiksel işleme kapalıdır.

2- karaktersel değerler: char keywordu ile tutulur , '...' içerisinde yazılırlar. 'a' , 'b' vb.

not : 'ab' şeklide birden fazla karakter barındırması durumunda program bu noktada hata verecektir.

3- mantıksal değerler : bool keywordu ile tutulur. true ya da false değerleri alabilir.

not : "True" ile true aynı şey değildir.

4- sayısal değerler : int,short,long,decimal .... gibi keyword ler ile tutulurlar. herhangi bir tırnak kullanmayız.

not : sayısal ifadeler varsayılan olarak int türündedirler.

5- ondalıklı değerler : float , double ve decimal keywordu ile tutulurlar. 

not : tüm ondalıklı sayılar tamsayıları karşılayabilirler.

a- float : bu türde bir değişkene değer ataması yapılırken değerin sonuna f veya F ifadesi eklenmelidir.

float @float = 3.14f , float @float2 = 3.15F vb.

b- double : bu türde bir değişkene değer ataması yapılırken değerin sonuna d veya D ifadesi eklenmelidir.

double @double = 3.16d veya double @double2 = 3.17D vb.

c- decimal : bu türde bir değişkene değer ataması yapılırken değerin sonuna m veya M ifadesi eklenmelidir.

decimal @decimal = 3.17m veya decimal @decimal2 = 3.19M vb.


not : ondalıklı türlerde bir değer default olarak double dır. (sonuna d veya D gelmesi gerekir.) default olduğundan dolayı değerin sonuna d ve D koymasak da olur.

not : char türünde bir değişken tanımlayacak isek "..." şeklinde çift tırnak kullanamayız.
not : string türünde bir değişken tanımlayacak isek '...' şeklinde tek tırnak kullanamayız.

tuple türünde veri atama : 

tuple : tek bir syntax üzerinde birden fazla değişken tanımayabilmemizi sağlayan bir nesnedir.

not : tuple değişken içerisinde int, string , double , vs olmak üzere birden fazla aynı veya farklı türde değişken tanımı mevcuttur.

(int a, string b) @tuple = (5,"kemal");

literal düzenleme : int x = 1000000; şeklinde gösterimi int x=1_000_000; şeklinde de gösterebiliriz.


// değişken türüne uygun default değer atama;

tüm değişkenlerin bir default değeri vardır. 

not : main fonksiyonu içerisinde tanımlanan bütün değişkenlerin default değerleri otomatik olarak atanmaz,
class içerisinde tanımlanan fonksiyonların değerleri default olarak atanır.

varsayılan değerler : 

bool : false,
sayısal : 0,
char = '0',
strign = null

main içerisinde bu deperler otomatik olarka gelmez class içerisinde tanımlanan değerlerde otomarik olarak gelir.

main scopu içerisinde default değeri atamak için,

bool x = default;

Console.WriteLine(x);

console a False değeri yazılır.

// tanımlanmış bir değerin değerini okuma :

int x = 5;  // (integer türünde x adında bir alan tahsis edildi ve içerisine 5 değeri atandı.)

int y = 10;  // (integer türünde y adında bir alan tahsis edildi ve içerisine 10 değeri atandı )

int z = x ;  // (integer türünde z adında bir alan tahsis edildi ve içerisine x (yani 5 değeri) atandı)

z = y ;  // (daha önce z adını alan ve türü belirtilen bir alan tahsis edildiğinden herhangi bir hata oluşturmadan z değişkenine y ( yani 10 değeri) atanır.)

b = x ;  // (daha önce b adında bir değişken adı ve türü belirtilmediği için bu kod satırı hata verecektir.)


RAM'da alan tahsis edilirken 2 kritik vardır. bunlardan bir tanesi eksik olursa değişken tanımlanamaz.

1- veri tipi ( int , string, bool, char vb.)
2- değişken ismi ( isim , numarala, sira , sayi vb.)


önemsiz not : int a = 5; a = a ; dediğimizde herhangi bir hataya sebebiyet vermez. bir değişkene aynı türde aynı değeri saklaması için verebiliriz.


// değeri olmayan değişkenler. 

main içerisinde atanmış bir karşılığı olmayan değer ile ( int x ;) hiç bir şey yapamayız. 
çünkü burada uygulamaya int türünde ve x isminde bir alan tahsis edeceğiz dedik ve main yapısı gereği default değer atamaz.
ancak bu (int x;) ataşmış karşılığı olmayan bir değişkeni class içerisinde kullanabiliriz. default değerler otomatik atanır.



// değişken davranışlarına genel bakış , 

bir değişkenin kendini göndermek ile değerini göndermek arasında fark vardır. 
değerini göndermek şu şekilde olur.

int x = 9;  // (burada stack alanında int türünde x adında içerisinde 5 değerinin tutulduğu bir alan tahsisi yaptık.)
int y = x;  // (burada stack alanında int türünde y adına içerisnde x in değerinin tutulduğu bir alan tahsisi yaptık.) x in kendisini atmadık , değerini tanımladık.
y = 20;  // (burada stack te barındırılan y değişkenine 20 değerini atadık. x değişkenine herhangi bir şey olmadı.)

Console.WriteLine(y);  // 20 


// değişkenlerin faliyet alanları : 

scope : değişken ve fonksiyonların sınırlarını belirler. tanımlamalarda ve algoritmik çalışmalarda karışıklığı önler.

{ } --> scope 


not : bir scope içerisinde tanımlanan değişkene o scope içerisinde tanımladığı satırdan sonra herhangi bir yerden erişebiliriz.
iç içe tanımlanan scope larda en dışta tanımlanan scope daki değişkene en içteki scope dan erişebiliriz ancak tersi mümkün değildir.


scope lar nerelerde kullanılır;

1- namespace , classlarda , metotlarda , döngülerde , if yapısında scope kullanılır.
2- herhangi bir keyword e bağlı kalmadan da scope oluşturabiliriz.


// değişmezler.

sabitlere neden ihtiyaç duyarız?

- bazen sabit değerler ile de çalışmamız gerekebilir. 
sabitlerin asıl amacı bir başka yazılımcı tarafından değiştirilmesini istemediğimiz durumlarda kullanırız. bir diğer avantajı ise
kendi hatalarımızın önüne geçmektir. dalgınlıkl değiştirmememiz gereken bir noktada deişmemesi gereken bir değeri değiştirebiliriz.

development aşamasında 'sabit' olarak tanımlanmayan bir değer değiştirilirse hehrangi bir hata ile karşılaşmadan compiler işlemi tamamlanır.
en erken uygulama çıktılarını görüntüleme aşamasında mantıksal hatalar olduğunu anlayabiliriz. bu noktadan sonra hatanın yerini tespit etmemiz birhayli uzun sürecektir.

sabitleri nasıl tanımlayabiliriz ? 

- const keywordu ile tanımlarız.

prototip olarak değişkenlere çok benzer ancak davranışsal olarak değeri bir daha değiştirilemez. değiştirme aşamasında hata mesajı alırız.
özünde staticdir.

static nedir ? 

- static uygulama bazlı veri depolayabildiğimiz bellekte bir alandır.

- scope içerisinde tanımlanan bir değişken gene sadece aynı scope içerisinden erişime izin verir, static'e konulan bir değer / değişken evrenseldir ve uygulamanın herhangi bir yerinden erişime açıktır.

static ile const arasındaki fark nedir ? 

- static değişkendirler , const'lar değişmezdirler.

readonly : sadece okunabilir değişkenler tanımlanmaktadır.

const tanımlandığı anda değer ataması yapılmak zorundadır. alan tahsis edeyim, ileride bu alanı dolduracağım olmaz.

readonly de ise const'a ilave olarak constructure da da değer ataması yapabiliriz. 3.bi değer ataması yapamayız, bir defa değer ataması yapınca değiştiremeyiz.

readonly static değildir.

const değişken tanımlama : 

int a = 5 ;         // (bu şekilde int türünde a adında içerisinde 5 rakamının tutulduğu alan tahsis ettik ama kapı her zaman açık)

a = 8;              // (bu şekilde a değişkenine giderek değiştirebiliriz.)

const int b = 7;    // (bu şekilde int türünde b adında içerisinde 7 değerinin tutulduğu alan tahsis ettik ve const ile kapıyı kilitledik.)

b = 11;             // (const ile kapıyı kiltlediğimizden dolayı b değeri üzerinde değişiklik yapamayız.)



// global ve local değişkenler , 

bir değişken konumlandığı yere göre locak veya global diye isimlendirilirler. yapı ve işleyişte herhangi bir değişiklik olmaz sadece isimlendirme yapılmıştır.

class scope u içerisinde tanımlanan değişkenlere global değişken denir.
metotlar içerisinde tanımlanan değişkenlere local değişlen denir.


// değişken tanımlama varyasyonları: 

1- int a; veya int a = 5;   // klasik varyasyon

2- aynı türde birden fazla değişken oluşturulması gereken durumlarda kullanılabilir.
int x = 3, y= 4, z=5; --> alan tahsis ettik ve değer atamsı yaptık.
int x,y,z;  --> alan tahsis ettik ve değer ataması yapmadık.

// değişkenler arası değer atama.

1- deep copy : eldeki veri klonlanır. 1 iken 2 veri oluşur.

not : değer türlü değişkenler birbirine atanırken default olarak deep copy geçerlidir. yani veri otomatik olarak türetilir.

int a = 7;  ---> (stack alanında int türünde a isminde 7 değişkenini tahsis ettik.)
int b = a;  ---> (stack alanında int türünde b isminde a değişken (değerini deep copy olarak) tanınladık. )
b = b * 3;  ---> (deep copy olarak kopyaladığımız a değişken değeri değişmeden b üzerinde matematiksel işlem yapabiliriz.)

Console.WriteLine(a);  // 7
Console.WriteLine(b);  // 21 

b değişkeni a değişkeninden deep copy copyalandı ve sonrasında a değişkeni bu kopyalamadan etkilenmeyecektir.

2- shallow copy :  birden fazla referansla işaretlemeye dayalı kopyalama yöntemidir.

bellekte birden fazla referansın tek bir veriyi işaret etmesidir.

neticede ilgili değer bir değişikliğie uğradığında tüm işaretleyen referanslara da bu değişiklik yansıtılacaktır. (Autocaddeki blok editor mantığı)

A ve B değişkenleri heap daki aynı değeri kullanıyorlar, heap daki değer değişirse A ve B bu durumdan etkilenecek.

not : değer türlü değişkenlerde bilinçli olarak shallow copy yaptırılabilir. 

not2 : nesne ve referans arasındaki ilişkide varsayılan davranış olarak kabul edilmektedir.

// object türü : 

tüm türleti karşılayabilen , referans türlü ve stack de tutulmayan bir türdür.
object olarak tanımlanan değişkenler şeffaf bir kutu gibi içerisinde tutulmuş gibidir. object içerisinde herhangi bir türde , tür değişmeden tutulur. (boxing özelliği)


boxing özelliği : 

object bir değişkene herhangi bir türdeki değer türünde bir değişikliğe uğramadan göndermektir. boxing işlemi neticesinde ilgili değer object in içerisinde kendi türünde saklanır.

object türünde tutulan hangi tür veri olursa olsun o türde bir işleme tabi tutulamaz. int ise matematiksel olarak işlem yapılamaz, string ise metinsel işlemler yapılamaz.

boxing işlemini şeffaf bir kutu olarak düşünebiliriz. içerisi görünüyor ancak işlem yapmaya kapalı.

şeffaf kutulama olarak adlandırdığımız boxing de tutulan değişkeni işlem yapılabilir hale getirmek için unboxing işlemi yapmak gerekir.

// cast operatörü : 

boxing edilmiş bir veriyi kendi türünde işleme açabilmemize yardımcı olan bir opeartördür.

not : bilinçli tür dönüşümünde de cast operatörü kullanılır. 
not2: kalıtımsal durumlarda da cast operatörü kullanılır.

() ---> cast operatörü . object değeri alır.

cast kullanımı : 

object A = "cem";                   ----> veri türü : object , değişken ismi : A 

string isim = (string)A ;           ----> veri türü : string , değişken ismi : isim (cast ı burada kullandık) (cast olarak türüne uygun olarak değeri istemek gerekir.)

Console.WriteLine(isim.ToUpper());  ----> veri türü : string , değişken ismi : isim 

cast object boxing unboxing iç içe ifadelerdir. buna bi örnek verelim.

object _yas = 32; ---> veri türü : object , değişken ismi : _yas olan bir alan tahsis ettik. 

Console.WriteLine(_yas*3);  ---> sonuç ekrana bastırılamaz.

int yas = (int)_yas ; ---> _yas isimli değişkenini cast operatörünü kullanarak unboxing yaparak int değişkeni içerisine koyduk.

object neden kullanılır? 

- dışarıdan alınan verilerin türleri bilinemediği durumlarda kullanılır.

not : int olarak boxing edilen bir veriyi string veya char türünde unboxing edersek runtime esnasında (tam son noktada) hata verir. bigbang


// var keywordu nedir ? ne işe yarar? 
 
Tutulacak değerin türüne uygun bir değişken tanımlamak bizim elimizdedir. ancak bazen bunu biz compilera yaptırmak isteriz. bunu var keywordu ile tanımlarız.

bool medeniHal = true;     // var medeniHal = true;
string isim = "nazmi";     // var isim = "nazmi";

bunları biz tanımladık          bunları compiler yaptı.


'var' keywordu atanan değerin türüne bürünür.

var ne zaman kullanılır ? 

diller arası entegrasyonda kullanılır. X dilinde tanımlanan t adında bir değişken vardır diyelim , biz bu t adındaki değişkenin C# dilindeki karşılığını bilemeyebiliriz.
bu noktada 'var' yazıp geçeriz.


not1: 'var' keywordu ile tanımlanan değişkenin değeri tanımlama aşamasında verilmelidir.
not2: 'var' keywordu ile tanımlanan değişkene ilk değer verildikten sonra o türe bürüneceğinden dolayı aynı tür üzerinden ilerlemek gerekir.
not3: 'var' ile object arasındaki fark , var işleme açıktır , object unboxing etmeden işleme kapalıdır.


// dynamic keywordu : 

dynamic b = 5; ---> development sürecinde b her daim dynamic türde görünecektir. uygulama derlenip çalıştırıldığında dynamic ilgili değerin türüne bürünmüş olur.

var x = 5;   ---> bu satırdan sonra x integer bir davranış sergiler ve integer e has işlemlere tabi tutulabilir.

dynamic y = 10 ; ---> bu satırdan sonra runtime a kadar y dynamic davranışlar sergiler.


dynamic özelliği nedir ? 

- . ya bastıktan sonra otomatik olarak kullanılabilecek özellikler listelenir.

Console.SetWindowSize
Console.Write
Console.WriteLine
Console.SetWindowPosition

buradan Console. dan sonra liste çıkar ve kullanılabilecek olan özellikler listelenmiş olur. burada Console dynamic olsaydı . ya bastıktan sonra hiç bir özellik görünmeyecekti.

dynamic olan verilerde manuel olarak .Write , .WriteLine şeklinde yazmamız gerekir. buna karşılık bir hata olup olmayacağını dotnet run demeden bilemeyiz.

not : dynamic keywordu runtime türü belirleyecektir ancak kararlı davranmayacaktır. bunu bi örnekle açıklayalım.


dynamic x = "ali";
Console.WriteLine(x.Gettype());
x = true;
Console.WriteLine(x.GetType());

// string
// boolean


dynamic geçici veri tutma yeridir diyebiliriz.

dynamic nerelerde tercih edilir?

türünü bilmediğimiz ve verinin geldiğini düşünelim. var keywordu uzaktan gelen verilerde kullanılmaz.

not : uzaktan gelen verilerin hangi türde olduğunu bilmediğimiz verileri karşılarken dynamic keywordu kullanılır. 
uzaktan gelen veriyi var ile tanımlayamayız çünkü var tanımlandığı anda verinin atanmasını ister. dynamic runtime'a kadar bekleyebilir.

int b = 5;
b="kale";
b = true;

int veya başka bir belirli tür bu değişikliğe izin vermez.

dynamic a = 3;
a = true;
a="isim";

dynamic türde esneklik sağlar.


// değişkenler genel tekrar soruları:

1- değişken nedir ve neden ihtiyaç duyarız.

yazılımın amacı eldeki verileri bir şekilde anlamlı hale getirmektir. elimize bir şekilde geçen verileri , bu elimize geçme bir işlem neticesinde olabilir , 
bir veri tabanından gelebilir , bir client tarafından gelebilir. developer ların amacı bu veriyi amacına uygun bir şekilde yönlendirerek arzu edilen sorulara
cevap vermektir.

2- value type , primitive type , nedir ? 

value type      : yas , isim , tckimlik gibi değişkenleri tutan değerlerdir.
primitive type  : diğer türler tarafından türetilmiş türlerdir.

Console.WriteLine(typeof(bool).IsPrimitive);        // True
Console.WriteLine(typeof(char).IsPrimitive);        // True
Console.WriteLine(typeof(sbyte).IsPrimitive);       // True
Console.WriteLine(typeof(byte).IsPrimitive);        // True
Console.WriteLine(typeof(short).IsPrimitive);       // True
Console.WriteLine(typeof(ushort).IsPrimitive);      // True
Console.WriteLine(typeof(int).IsPrimitive);         // True
Console.WriteLine(typeof(uint).IsPrimitive);        // True
Console.WriteLine(typeof(long).IsPrimitive);        // True
Console.WriteLine(typeof(ulong).IsPrimitive);       // True
Console.WriteLine(typeof(float).IsPrimitive);       // True
Console.WriteLine(typeof(double).IsPrimitive);      // True
Console.WriteLine(typeof(decimal).IsPrimitive);     // False
Console.WriteLine(typeof(object).IsPrimitive);      // False
Console.WriteLine(typeof(string).IsPrimitive);      // False


buradan çıkartılacak sonuç decimal , object ve string türleri primitive tür değillerdir.

not : tanımlanmış bir dğeişkene değer atamak için önceden o değişkenin tanımlanmış olması zorunludur.

örnek :

int a ;

a = 6;  // dada önce stack alanında 'a' isminde bir değişken ve alan oluşturduğumuz için içerisine türüne uygun bir değer ataması yapabiliriz,
b = 9;  // daha önce stack alanına 'b' isminde bir değişken ve alan oluşturmadığımız için içerisine herhangi bir değer ataması yapamayız.


tuple türü : içerisinde birden fazla değişken barındırabilen bir yapıdır.


/// kod nasıl çalışır ;

kodun çalışması için geliştrilmiş 2 adet yöntem vardır.

1- senkron çalışma  : bir işlem bitmeden diğer bir işlemin başlamadığı , yöntemdir. (trafikte öndeki araba gitmeden arkadaki araba gidemez).
                    bu yöntemde herhangi bir t anında yapılan işi tespit edebiliriz.

2- asenkron çalışma : paralel olarak birden fazla işin aynı anda yapılması yöntemidir. (oyun oynarken müzik dinlemeyebiliriz).
                    bu yöntemde herhangi bir t zamanında yapılan işi tespit edemeyiz.


not : yazılımlar varsayılan olarak senkron çalışırlar , ancak gelişen teknolojiler sayesine tamamına yakını asenkron olarak yola devam ederler.



/// kod konsepti nasıldır ? nasıl oluşturulur

kod inşa edilirken her zaman şu yapı vardır.

_____________ = _____________
tür ,           bu taraftaki yazılı olan kodlar bir işlem
referans,       yapacak ve geriye bir değer döndürecek.
değişken vs.    (değer döndürmeyede bilir , böyle durumlarda bu kısım olmaz.)

sağ tarafta bir işlem yapılacak ve sol taraftarki tür , referans , değişken vs ye atanacak.


/// ; operatörü

; operatörü compiler tarafından konseptin bittiğini işaret eder. compiler satır satır değil konsept konsept çalıştığından dolayı bu ; operatör üçok önemlidir.

not : bir konsept biter ve konseptin sonuna ; işaretini koymaz isek hata alırız:
nor : ; operatörü birden fazla kullanılabilir herhangi bir hataya sebebiyet vermez ancak hoş karşılanmaz. 
not : compiler tarafından kodlar satır satır değil konsept konsept derlenir.


/// tür dönüşümü nedir ve neden ihtiyaç duyarız?

development sürecinde elimizdeki verilerin türlerini değiştirebiliriz. ancak her tür istediğimiz bir türe dönüşemez. 
örneğin elimizde bir 'elma' var ve biz bu elmayı en fazla bir üst sınıf olan 'meyve' türünde saklayabiliriz.
bir development hiçbir şeyi boş yere yapmaz. kodlamanın temel mantığını biz elimze bir şekilde gelen veriyi uygun hale getirerek,
uygun çıktılar oluşturmak için bu yola girdik , ve bu yolculukta elimze string bir değişken geldiğini varsayalım. 
bu string ifadenin değeri "123" olsun. bu veriyi string olarak *2 işlemine tabi tutamıyoruz ancak çarpmamız gerekiyor.
tam bu noktada tür dönüşümüne ihtiyacımız vardır.


not : tür dönüşümleri mantıksız olmamalı.
not : farklı servislerden gelen verileri uygun türlere dönüştürme ihtiyacı olabilir, bu noktada tür dönüşümü yapılmalıdır.
not : elimzideki veriye uygun olmayan bir türe dönüştürmeye çalışmak hatalara sebebiyet verebilir. örneğin bool türündeki bir veriyi char içinde tutamayız.

örnek  : elimizde 'meyve' verisi var. 'meyve' içerisinde elam olduğunu biliyoruz, bu türü 'armut' olarak dönüştürürsek patlarız.
örnek2 : bir şekilde elimize 'ahmet' diye bir veri geldi. biz bu veriyi bool türüne dönüştüremeyiz.
örnek3 : bir şekilde elimize "123" diye bir veri geldi . biz bu veriyi char türüne dönüştüremeyiz.


/// Parse fonksiyonu:

metinsel ifadeleri diğer türlere dönüştürmeye yarayan fonksiyondur.
herhangi bir string ifadeyi int , bool , char gibi türlere dönüştürür.

not : sadece string ifadelerde dönüşüm yapabilir.


string ------> Parse ------> char (olur)
string ------> Parse ------> int (olur)
string ------> Parse ------> bool (olur)
int    ------> Parse ------> string (olmazzzzzz)

kullanımı : 

string x = "123";

Console.WriteLine(int.Parse(x) * 2); -----> // 246 

çözülmesi gereken soru:

dışarıdan elimze string bir ifade geldi ve biz bu ifadenin 2 katını alacağız.

çözüm :

sonuca ulaşmak için 2 ile çarpabilmek için matematiksel bir ifadeizin olması gerekir. 
bu sebepten dolayı elimizdeki veriyi matematiksel bir veriye dönüştürdük ve sonuca ulaştık.


önemli not : tür dönüşümlerinde dikkat edilmesi gereken tek husus dönüşüm yapılacak verinin türüne uygun bir hedef belirlemektir.

dynamic x1 = "12";

Console.WriteLine(short.Parse(x1)*2); -----> // 24

var a = "9";

Console.WriteLine(double.Parse(a)*2); -----> // 18

object a1 = "7";

string b = (string)a;       ---> object türündeki veriyi burada unboxing yaparak string bir veriye dönüştürdük.

Console.WriteLine(int.Parse(b)*3);  -----> // 21

bu son örnekte object türünden bir veri üzerinde işlem yaptığımızdan kaynaklı olarak boxing-unboxing işlemine tabi tutma ihtiyacı oluştu.

/// convert fonksiyonu : 

herhangi bir türü herhangi bir türe dönüştürmek için kullanılır. Parse komutunun yaptıklarını da yapabilir.

not : int16 - short türüdür
      int32 - int türüdür
      int64 - long türüdür.


parse fonksiyonu ile dönüşüm : 

string x = "123";

Console.WriteLine(int.Parse(x) * 2); -----> // 246 

convert fonksiyonu ile dönüşüm:

string x = "123";

Console.WriteLine(Convert.ToDouble(x) * 2); -----> // 246 

int a = 100 ;

Console.WriteLine(Convert.ToString(a)+2);         -----> // 1002
Console.WriteLine(typeof(a));                     -----> tür dönüşümü yapılan bir değişkenin typeof ile türünü bulamadık.

/// metinsel olmayan ifadeleri metinsel ifadeye dönüştürmeye alternatif 

metinsel olayan ifadeleri convret fonksiyonu yardımı ile yapıyorduk ancak burada bir yöntem daha var. tostring fonksiyonu.

int a = 100 ;

Console.WriteLine(a.ToString()+100); -----> //100100  

(herhangi bir türdeki verileri string ifadeye çevirmek istersek Convert kullanmadan da bu şekilde yapabiliriz.)

bu özellik sadece string e çevirmek için kullanılır. 

/// sayılar verilerde kendi aralarında tür dönüşümleri .

2 şekilde bu tür dönüşümü mümkünüdür.

1- en dar aralıktaki türden en geniş aralıktaki türe dönüş. 

(en dardan en genişe türler)

byte < short < int < long < float < double < decimal

örnek vermek gerekirse byte türünde bir değişkeni herhangi programa herhangi bir açıklama yapmadan short veya daha üst bir sınıfa dönüştürebiliriz.

byte a = 10;
short b = a;        // burada herhangi bir hata ile karşılaşmayacağız ve program bu dönüşümü otomatik olarak yapacaktır.


2- en geniş aralıktaki türden en dar aralıktaki türe dönüş,

byte < short < int < long < float < double < decimal

örnek vermek gerekirse long türünde tanımlanmış herhangi bir değeri herhangi bir açıklama yapmadan (değer aralığı içerisinde ols dahi) int , short , byte türlerine dönüşüm yapamayız.

long a = 100;
int b = a;      // burada hata ile karşılaşırız. sebebi herhangi bir açıklama yapmadan türü daraltıyor olmamızdır.

long a = 100;
int b = (int)a ;    // bu şekilde cast operatörleri içerisine a dönüşüm yapmak istediğimiz türü yazarsak hata ile karşılaşmayız. bir nevi programa açıklama yapmış oluyoruz.

bu örnekte long bir alt tür olan int e dönüştü ancak short veya byte türüne de dönüşebilirdi. 

not : eğer değer aralığı dışında kalan bir rakam olursa modunu alarak kalan sayıyı ekrana yazdırır.

?? tür dönüşümlerine neden ihtiyaç duyarız ??

farklı türlerdeki verileri birbirleri ile işleme alabilmek için , örneğin bir tam sayı ve bir metin değerini toplamak gerekse bunu yapabilmek için her 2 değerin de 
aynı türde olması gerekir.

- veri kaybını önlemek için,
- veriler ile işlem yapabilmek için,
- veri türü karışıklığını çözebilmek için,
- veri türü uyuşmazlığını giderebilmek için...

tür dönüşümleri yapılır.

not : ister değer aralığında olsun ister olmasın ne zaman alt türe dönüşüm yapmamız gerekse cast opertörü ile dönüştüreceğimiz türü bildirmemiz gerekir.

detay : 

int a = 3000 ;

short s = (byte)a;  -----> burada int ifadesi byte türüne explicit edilmiş ve oluşan değer short türüne implicit edilmiştir.


/// checked ve unchecked 


checked : explicit tür dönüşümü yapılırken runtime de bir hata fırlatılmasını sağlar. bu checked kullanılmaz ise herhangi bir hata almadan veri kaybı arka planda gerçekleşir.

{
    veri kaybı potansiyeli olan dönüşüm kodları bu alana yazılır
}

unchecked : explicit tür dönüşümü yapılırken hata fırlatmadan uygulamanın çalışmaya devam etmesini sağlar. 

NOT : tür dönüşümleri default olarak unchecked dir.

/// özel türler arasında tür dönüşümleri 

1- bool ile sayısal değerler arasında tür dönüşümü,
2- sayısal değerler ile bool arasında tür dönüşümü,
3- char ile sayılar türler arasında tür dönüşümü,
4- sayılar türler ile char arasında tür dönüşümü.

1- bool ile sayısal değerler arasında tür dönüşümü,
    elimizdeki mantıksal değer taşına bir veriyi herhangi bir sayısal veriye convert edersek ilgili değerin sayısal karşılığını elde ederiz.

    true ---> 1
    false ---> 0

    örnek : bool b = true;
            int i = Convert.ToInt32(b);

            Console.WriteLine(i);       ---> 1

            içerisinde true değeri taşıan b isimli boolean türündeki bir veriyi dönüştürdük.

2- sayısal değerler ile bool arasında tür dönüşümü,
    Elimizdeki sayısal değer taşıyan bir veiriyi mantıksal bir veriye convert edersek ilgili değerin mantıksal karşılığını elde ederiz.

    örnek : 
        short s = 1;
        bool a = Convert.ToBoolean(s);
        Console.WriteLine(a);       ---> true
    
not : 0 dışındaki bütün değerlerin mantıksal karşılığı true dur.

3- char ile sayılar türler arasında tür dönüşümü,
    klavyede görünen her bir karakterin arka planda bir ASCII kodu vardır.


    ASCII kodları :

    A   B    C   D   E   F   G   H   İ   J   K   L   M   N   O   P   R   S   T   U   V  W   X   Y   Z 
    65  66  67  68  69  70   71 72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89


    a   b    c   d   e   f   g   h   ı   j   k   l   m   n   o   p   r   s   t   u   v   w   x   y   z
    97  98  99  100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121

    ASCII : bilgisayardaki her bir karakterin sayısal bir karşlığı vardır. bu sayısal değerlere ascii kodları denir.

    char türündeki herhangi bir veriyi integer veri türüne dönüştürmek istersek bize ascii kodlarını verir. tersi de mümkündür.
    

    örnek :
        char a = 'a';
        int b = (int)a ;
        Console.WriteLine(b);           ---> 97


        char a = '-';
        int b = (int)a;
        Console.WriteLine(b);           ---> 45

    bu tür dönüşümlerde explicit tür dönüşümü yapılır. 



4- sayılar türler ile char arasında tür dönüşümü.

    örnek;

        int deger = 97;
        char @char = (char)deger;
        Console.WriteLine(@char);           --->    a


// tür dönüşümleri genel konu tekrarı:

1- tür dönüşümlerini neden yaparız ?
    yazılım demek elde edilen verileri uygun algoritmalar yardımı ile doğru yöntem ve şekiller yardımı ile istenen çıktıyı oluşturmaktır. 
    veriler bu yolculuk esnasında bazı işlemlere tabi tutulurlar , bunlardan bir tanesi de tür dönüşümleridir.
    bu dönüşümlere veriler arasında karşılaştırma yapabilmek , veriler üzerine matematiksel işlemler yapabilmek , bellek optimizasyonu gibi sebeplerden ihtiyaç duyarız.
2- parse fonksiyonu nedir ne için kullanılır?
    sadece string ifadeler üzerinde çalışan bir fonksiyondur. string türe veya string türden bi dönüşüm olması durumunda kullanılır.
3- convert fonksiyonu nedir ne için kullanılır?
    bütün tür dönüşümlerinde çalışan bir fonksiyondur. 
4- sayılar türlü verilerin kendi aralarında tür dönüşümleri nelerdir?
    genel anlamda bellek optimizasyonu için kullanılır. byte türü 8 bit lik yer tutarken decimal 128 bit lik yer kaplamaktadır.
    byte ile tutulabilecek bir veriyi decimal ile tutarak gereksiz bellek kullanımına yol açmışız demektir.
5- implicit ve explicit tür dönüşümleri nasıl yapılır?
    implicit tür dönüşümü sayılar veri türlerinde daha geniş bir değer aralığı tutan verilere bilgisayar yardımı ile dönüştümeye denir. 
    bu dönüşümde developer ilave herahngi bir şey yapmasına gerek yoktur. 

    explicit tür dönüşümü sayısal verileri daha dar bir değer araşoğı tutan verilere dönüştürmeye denir.
    bu dönüşümde bilgisayarın herhangi bir sorumluluğu yoktur. bütün sorumluluk developer dadır. 
    burada dikkat edilmesi gereken nokta byte kapasitesini aşmayan bir değeri daha üst segmentte bir türde saklıyorsak ve bunu byte türüne dönüştürmek istersek 
    gene explicit tür dönüşümü yapmak gerekir. BİLGİSAYAR VERİNİN TÜRÜ İLE İLGİLENİR , VERİNİN DEĞERİ İLE DEĞİL...
6- checked ve unchecked kavramları?
    normal şartlarda bilinçli tür dönüşümlerinde herhangi bir hata ile karşılaşmadan arka planda işlemler gerçekleşir.
    burada bilinçli olarak tür dönüşümünde hata fırtlatmak istediğimiz bir durumda 'checked' olayını kullanabiliriz.

    checked
    {
        short @short = 300;
        byte @byte = (byte)@short;
        Console.WriteLine(@byte);
    }

    bu kodlar checked arasına yazılı olmasaydı herahangi bir hat görünmeden arka planda yapılacaktı. 

7- özel tür dönüşümleri ?
    bool - sayısal , sayısal - bool , char - sayısal , sayısal - char arasındaki tür dönüşümleridir.

    sayısal - bool dönüşümlerinde 0 harici bütün değerler true olarak gelir.
    sayısal-bool , bool-sayısal tür dönüşümleri convert ile yapılır.
    char-sayısal , sayısal-char tür dönüşümleri explicit olarak yapılır. ve sonuç olarak ascii kaynak kodlarını döner.

    
8- ascii kaynak kodları nedir ve ne işe yararlar ?
    klavyedeki her bir ifadenin ascii kaynak kodu karşılığı vardır. bu kodlar bilgiayar sistemlerinde sıkça kullanılırlar.


/// operatörler nedir ?

bir işin sorumluluğunu üstlenen temel yapı taşlarıdır , bir operasyon gerçekleştirirler.

bir operatör teorik olarak sağında ve solunda bulunan değerler üzerinde bir bağıntı oluştururlar.

opertörler kullanılırken geriye dönüş değerlerine dikkat edilmelidir. 

operatör çeşitleri;

1- aritmatik operatörler,
2- karşılaştırma operatörleri,
3- mantıksal operatörler,
4- özel işlemler operatörleri.
5- metinsel ifalerde kullanılan operatörler.

1- matematiksel operatörler
    + , - , * , / , % 
    iki sayısal değer üzerinde işlem yapan operatörler oldukları için işlem neticesinde 'uygun' türde sonuç return ederler.

    oparetörler geriye hangi değer dönüreceğini visaul studio code özelliği gereği önizmele olarak bizlere söyler.

    not : aynı türde yapılan aritmatik işlemlerin sonucu gene aynı türde return edilir. bu noktada istisna olarak 2 tane byte türü arasınd yapılan işlemler 
    int türünde return edilmektedir. 2 farklı türde yapılan aritmatik işlemlerde sonuç büyük olan türde olacaktır.

    int x = 3;
    double y = 325;
    sonuc = x + y ;
    Console.WriteLine(sonuc)        ---> sonuç double türünde olacaktır.

    not : 2 'byte' türü arasında yapılan aritmatik işlemlerin sonucu 'int' türündedir.

2- karşılaştırma operatörleri,

    > , < , >= , <= , == 

    iki sayısal değer arasında büyüklük , küçüklük , eşitlik durumuna göre karşılaştırma yapan operatörlerdir.

    not : metinsel ifadelerdede == operatörü kullanılabilir.

    karşılaştırma operatörleri true ya da false döner.

3- mantıksal operatörler,
    && , || , ^ 
    tüm şartları değerlendirip kendine göre sonuç döndüren operatörlerdir. bu operatörler geriye bool değer döndürürler.

    || ile ^ arasındaki temel fark : 

    || operaötünde en az 1 adet true olması gerekir,
    ^ operatöründe 2 durumdan yanlızca 1 tanesi doğru olması gerekir.

    && (ve operatörü)
    true && true ---> true
    true && false ---> false
    false && true ---> false
    false && false ---> false

    || (veya opertörü)
    true || true ---> true
    true || false ---> true
    fasle || true ---> true
    false || false ---> false

    ^ (ya da operaötür) her 2 ihtimalden yanlız birisi gerçekleşecek.
    true ^ true ---> fasle
    false ^ true ---> true
    true ^ false ---> true
    false ^ false ---> false


4- özel işlemler operatörleri.
    ++ , -- , += , -= , *= , /= , ! , != 

    ++ , -- operatörleri : bir artırma veya 1 azaltmaya yarayan operatörlerdir.

    int i = 5;  ---> i ye 5 değerini atadık.
    i ++;   ---> compiler bunu (i = i+1) olarak okudu.

    i++ ile ++i arasındaki fark nedir ?

    ++i önce i değerini 1 artırır sonra i değerini return eder , i++ da ise önce i değerini return eder daha sonra değeri 1 artırır.

    Örnek : int i = 10;
            Console.WriteLine(i++);     ---> 10

            int i = 10 ;
            Console.WriteLine(++i);     ---> 11
        
    += , -= , *= , /= operatörleri : üzerine ekleme ve yığma oparetörleridir. tamamı aritmatik işlemlerde kullanılır. ilave olarak += operatörü metinsel ifadeler için de kullanılabilir.

    örnek : int i = 5;
            i += 4 ;
            Console.Writeline(i);       ---> 9

            int i = 5;
            i -= 1 ;
            Console.Writeline(i);       ---> 4

            int i = 5;
            i *= 2 ;
            Console.Writeline(i);       ---> 10

            int i = 5;
            i /= 2 ;
            Console.Writeline(i);       ---> 2

    ! operatörü : değil operatörü olarak bilinir. tek başına bir anlam ifade etmez, 

        ! operatörü kullanım örnekler;

        Console.WriteLine(!true);   ---> false
        Console.WriteLine(true);    ---> true

        Console.WriteLine(2 != 3 ); ---> true
        Console.WriteLine(3 != 3 ); ---> false


5- metinsel ifalerde kullanılan operatörler.

    + , += , == , !=

    + operatörü : metinsel ifadelerde birleştirme de yapan operötlerdir.

    string s1 = "adnan";
    string s2 = "Ziyagil";

    Console.WriteLine(s1+s2);       ---> adnanZiyagil

    += operatörü : bir metin üzerine başka bir metin ekleme yapan operatördür.

    string s1 = "adnan";
    string s2 = "Ziyagil";
    s1 += s2 ;              (tam bu noktada s2 değişkenini s1 değişkeni üzerine yığdık).
    Console.WriteLine(s1)  ---> adnanZiyagil

    == operatörü : 2 metinsel ifadeyi karşılaştırmak için kullanılır. sonuç olarak true veya false döner.

    string s1 = "adnan";
    string s2 = "Ziyagil";
    Console.WriteLine(s1==s1)  ---> false

    not : stirng ifadelerde > veya < karşılaştırma olarak kullanılamaz. 

    != operatörü : == ifadesinin tersini almada kullanılan operatördür. (eşit değilmi)

    string s1 = "adnan";
    string s2 = "Ziyagil";
    Console.WriteLine(s1!=s1)  ---> true

/// ternary operatörü : 

    kalıpsal bir operatördür ve çok fazla kullanılır. şarta bağlı değer döndüren bir operatördür.

    not : bir değişkene , değere, property e değer atarken , eğerki bu değer bir şarta göre fark edecekse satır bazlı / tek satırda bu şart kontrolünü yaparak 
    duruma göre değer döndürmemizi sağlayan kalıpsal bir operatördür

    not : ternary operaötür bir koşulu değerlendirir ve koşul doğru ise bir değeri , yanlış ise bir başka değeri döndürür.
        ternary opertörü if-else yapısının daha kısa bir  alternatifi olarak kullanılır.
    
    ternary operatörü 3 kısımdan oluşur.

    1- koşul : koşulu değerlendiren bir ifade (bool türünde olmalı),
    2- eğer doğruysa : koşul doğru ise döndürülecek değer,
    3- eğer yanlışsa : koşul yanlışsa döndürülecek değer.

    ___________________________ ? ___________________________: ___________________________;
    (bool sonuç üretecek alan)      (true ise dönecek alan)     (false ise dönecek alan)
   
    terbary operaötür ile yapılabilecek işlemler ,

    1- karşılatırmalar,
    2- atama işlemleri,
    3- döndürme işlemleri,
    4- null kontrolü,


    1- karşılaştırma :

     örnek :
        int i1 = 100 , i2 = 200;
        int max = (i1>i2) ? true : false;
        Console.Write(max);         ---> false

    2- atama : 
        int i1 = 100 , i2 = 200;
        int max = (i1>i2) ? i1 : i2;
        Console.Write(max);         ---> 200

    3- döndürme :
        int i1 = 100 , i2 = 200;
        int max = (i1>i2) ? i1 : i2;
        Console.Write(max);         ---> 200

    4- null kontrolü :
        string value = "hello world!";
        string result = value == "" ? value : "null";
        Console.WriteLine(result);          ---> hello world!

        bu kontrolün özelleştirilmiş bir hali vardır. şöyle ki,

        string value = "hello world!";
        string result = value ?? "null";
        Console.WriteLine(result);          ---> hello world!

    if-else yapısı ile ternary karşılaştırması :

    if-esle yapısı :

    bool medeniHal= true;

    if (medeniHal == true)
    {
        Console.WriteLine("Evlilere Kampamya");
    }
    else
    {
        Console.WriteLine("Bekarlara Kampanya");
    }

    ternary yapısı :

    bool medeniHal= true;

    string message = (medeniHal == true) ? "Evlilere Kampanya" : "Bekarlara Kampanya" ;

    Console.WriteLine(message);

    not : ternary operatöründe her iki ihtiamlde de döndürülecek değer aynı olmak zorundadır. if else yapısında döndürülecek sonuçlar farklı türlerde olabilir.

    ternary örnek :

    yaşı 25 den küçük olanlara A,
        25 e eşit olanlara B,
        25 den büyük olanlara C değerini döndüren bi ternary operatörü oluşturalım.

    int yas = 32;

    string sonuc = (yas<25) ? "A" : ((yas==25)? "B":"C");  
    Console.WriteLine(sonuc);           ---> c


/// assign operatörü

atama operatörlerinde sağ-sol önemlidir. 
eğer değişken sol tarafta çağırılıyor ise değişkenin kendisi , sağ tarafta çağırılıyorsa değişkenin taşıdığı değer gelir.

not : assign operatörü bazı durumlarda davranış değiştirerek referans etme davranışı sergileyebilir.

/// member access (üye erişim operatörü ".")

elimizdeki değerlerin türleri alt elemanlara sahiptir. bu alt elemanlara ulaşmak için "." operatörü kullanılır.

üye erşimi ne demektir ?

-   bir nesnenin veya sınıfın üyelerine erişmek için kullanılan bir işlemdir.

not : "." operetörü bir nesnenin üyelerine erişmenin yanında static üyelere erişmek için de kullanılabilir.

not : static üyeler nesne özellikleri oluşturmadan erişilebilen sınıf üyeleridir.

int a = 5;

a.CompareTo
 .Equals
 .GetHashCode
 .GetType
 .GetTypeCode
 .ToString
 .TryFormat

buradaki "." operatöründen sonra gelenler int türüne ait member access lerdir.

string b = "ali";

b.Aggregate
 .All
 .Any
 .Append
 .AsEnumerable
 .AsMemory
 .AsParallel
 .
 .
 .

buradaki "." operatöründen sonra gelenler string türüne ait member access lerdir.

/// cast operatörü 

daha mnce cast operatörlerini 3 yerde gördük

1- boxing edilmiş bir veriyi unboxing ederken,
2- explicit tür dönüşümünde 
3- char - sayısal özel tür dönüşümlerinde (ASCII Kodlarını verirdi)
4- polimorfizm durumunda base class referansı ile işaretlenen bir nesneyi kendi türünde elde edebilmemizi sağlamaktadır. (ileride göreceğiz)


/// sizeof operatörü:

bir verinin veya ifadenin bellekte ne kadar yer kapladığını integer olarak geriye döndüren operatördür. (kaç byte olduğunu verir.)

Console.WriteLine(sizeof(byte));    ---> 1
Console.WriteLine(sizeof(sbyte));   ---> 1
Console.WriteLine(sizeof(int));     ---> 4
Console.WriteLine(sizeof(uint));    ---> 4
Console.WriteLine(sizeof(double));  ---> 8
Console.WriteLine(sizeof(decimal)); ---> 16
Console.WriteLine(sizeof(float));   ---> 4
Console.WriteLine(sizeof(char));    ---> 2
Console.WriteLine(sizeof(long));    ---> 8


/// typeof operatörü :
bir veri veya ifadenin türünü döndürmek için kullanılan operatördür. türü tespit etmek için kullanılır.


/// default operatörü :

herhangi bir operatörün default değerini döndüren bir operatördür. 

default değer nedir ?

- geçerli her tür için yazılım tarafından varsayılan olarak tanımlanmış değerdir.

Console.WriteLine(default(decimal));    ---> 0
Console.WriteLine(default(string));     ---> null
Console.WriteLine(default(short));      --->0
Console.WriteLine(default(byte));       --->0
Console.WriteLine(default(long));       --->0
Console.WriteLine(default(int));        --->0
Console.WriteLine(default(byte));       --->0
Console.WriteLine(default(char));       ---> null

herhangi bir değişkene default değer atamak için;

short a = default;
int b = defaul;
string c = default;


/// is operatörü :

asıl kıllanım amacı boxing işlemine tabi tutulmuş herhangi bir değerin öz türüne ulaşmaktır.
is operatörü denetleme neticesinde boolean türünde değer döndürür.

object @object = true;

Console.WriteLine(@object is null);     -->False
Console.WriteLine(@object is Program);  -->False
Console.WriteLine(@object is int);      -->False
Console.WriteLine(@object is null);     -->False
Console.WriteLine(@object is bool);     -->True


/// is null operatörü

    bir değerin null olup olmmadığnı kontrol etmek için kullanılan ve geriye boolean değer döndüren opeartördür.

    örnek :

    string @string ="abcd";
    string @string2 ="";
    Console.WriteLine(@string is null);         ---> false
    Console.WriteLine(@string2 is null);        ---> True


not : 'is null' operatörünü sadece nullable olan değerler için kullanabiliriz.

not2: 2 tür değişken vardır.

1- değer türlü değişkenler : bunlar null olamazlar.
2- referans türlü değişkenler : bunlar null olabilirler. (string referans türlü bir değişkendir.)

/// 'is not null' 
    is null ile aynı görevlere sahiptir.


/// as operatörü:
    cast operatörüne alternatif olarak üretilmiştir. dönüşümlerde kullanılır.

    cast operatörünü sadece 3 alanda kullanabiliyorduk.

    1- boxing edilmiş bir veriyi unboxing ederken,
    2- explicit (bilinçli) tür dönüşümünde 
    3- char - sayısal özel tür dönüşümlerinde (ASCII Kodlarını verirdi)
    4- polimorfizm durumunda base class referansı ile işaretlenen bir nesneyi kendi türünde elde edebilmemizi sağlamaktadır. (ileride göreceğiz)

buradaki maddelerden 1.madde olan boxing-unboxing durumuna alterantif olarak türetilmiştir.

cast operötür ile boxing içerisinden everi alırken içerisindeki verinin türüne uygun bir değişkene atama yapmak gerekirdi. 
aksi halde hata alarak uygulamanın sonlanmasına sebebiyet verir.
as operatörü bu hatayı almamızı engelleyerek null değer dönüdrür. işlem gene yapılmaz ancak hata alarak programın durmasının önüne geçilmiş olur.

örnek : 

1- cast operatörü yardımı ile boxing edilmiş bir veriyi unboxing yaptık.

object @object = 123;
int a = (int)@object;   

2- as operatörü yardımı ile boxing edilmiş bir veriyi unboxing yaptık.

object @object = 123;
Type a = @object as Type ;

önemli not : 

as operaötörü kullanımlarında tür uygun olmadığında geriye null değer döndürür. 
geri döndüreeği null değerini karşılayabilecek bir tür ile karşılanmak isteyecektir.
buradaki ihtiyaca istinaden şunu söyleyebiliriz.
"as operatörü değer türlü değişkenler için kullanılamaz!"

detaylı örnek :

object @object = "ahmet";
string @object2 = (string)@object;

Console.WriteLine(@object);         ---> ahmet

object türü referans türlü olduğundan dolayı string ile cast edilmesinde herahangi bir hata ile karşılaşmadık.


object @object = "ahmet";
int @object2 = @object as int;

Console.WriteLine(@object);         ---> hata verdi.
Console.WriteLine("hello!!");       ---> hello!!

hatanın sebebi ise @object içerisinde taşınan değer string bir ifadedir. biz bunu int içerisine koymaya çalıştık. hata verip kapandığı için 'hello!!' ekrana yazılmadı.


object @object = "ahmet";
Program @object2 = @object as Program;

Console.WriteLine(@object2);        ---> null
Console.WriteLine("hello!!");       ---> hello!!

yukarıdaki koddan farklı olarak burada referans türlü bir değişkene atamaya çalıştık. int değer türlü değişken olduğundan veri ile uyumlu olması gerekirdir.
ancak referans türlü bir değişkene atanması durumunda null değer döndürebiliyoruz.
bu kod parçasına 2.satırda @object 'program' türünde mi diye sorduk. eğer 'program' türünde ise @object değerini ekrana bastıracaktı. değilse null dönecek. ve uygulamaya çalışmaya devam ederek 'hello!!' yazısı bastırılmış oldu.
as ile bu işlemi yapmamızın avantajı program sonlanmadan bu işlemi yapabiliyoruz. 
cast ile aynı işlemi yapmaya çalışsak program hata verip kapanacaktır.

/// nullable opearötürü(?) 

c# programlama dilinde değer türlü değişkenler normal şartlarda null değer alamazlar.
bir değer türlü değişkenin null değer alabilmesi için nullable opeartörünün (?) kullanıması gerekir.

int a = null;  (böyle bir satır hemen hata verir. bunu yapmamız program tarafından engellenmiştir.)
int? a = null; (bu şekilde ? ilavesini yaparak nullable olabilen olarak yolumuza devam edebiliriz.)

ayrıntı detay :

object x = 123;
int y = x as int;

normal şartlar altında bu şekilde işlem yapılamaz. çünkü as operötürünün çalışma mantığına göre null değer alabilen değerlere dönüşüm yapmak gerekir.
int null alabilen bir değişken türü değildir.

as çalışma mantığında 2 seçenek vardır.
1- bir değer döndürecek
2- null değer döndürecek
c# object türü içerisindeki değer ile ilgilenmez. 123 normal şartlarda int olabilir ancak programın çalışma mantığında değer ile ilgilenme yoktur. object türü boş bir değer de taşıayabilir.
bu sebepten dolayı null değer alabilen değişken türleri ile çalışmak ister bizim object.

yukarıdaki işlemde oluşan hataya sebep programın durmaması için kodları şu şekilde düzeltmemiz gerekir.

object x = 123;
int? y = x as int?;

burada int? nullable olduğundan dolayı object in gönlü oldu ve yola devam ediyoruz.

/// null-coalescing opearötürü (??)

    elimizde null olan bir değişken var ise null içerisine herhangi bir değer gönderebilmemizi sağlayan operatördür.

örnek:

    string a = null;
    Console.WriteLine(a ?? "merhaba") ;

    a null değil ise a değerini yazdır , null ise "merhaba" yazdır dedik. 

daha önceki derslerde gördüğümüz teranry operaötür ile de bunu yapabilirdik.

Console.WriteLine(a ?? "merhaba") ;
Console.WriteLine(a ==null ? "merhaba": a);

örnek2: 
    string a = "kemal";
    Console.WriteLine(a ?? "merhaba") ;

    bu kod parçasında;
    eğer a ifadesi null ise "merahaba" yazdır değil ise a ifadesini yazdır dedik. buradan yola çıkarak '??' operaötür kullanılırken her 2 veri de aynı türde olması gerekir.
    string bir değişkenin null olup olmadığını kontrol ediyorsak null olması durumunda elimize aynı türde başka bir veri geçmeli.
    işlem sonucu olarak elimize elimize int türünde veya bool türünde bir veri geçmemeli.

/// null-coalescing assignment (??=)

    c# 8.0 ile gelen bir özelliktir.
    amacı değeri null olan bir değişkeni hem ekrana bastırırken hem de devamında null yerine değer ataması yapmış oluyoruz.

    karşılaştırmalı örnek:

    string isim = null ;
    Console.WriteLine( isim ?? "merhaba");      ---> ?? operatörü kullandığımız için null olan değere karşılık "merhaba" ifadesi ekrana basıldı.
    Console.WriteLine(isim);                    ---> ?? operatörü kullandığımızdan için kodun devamındaki çağırmalarda "merhaba" yazmayacak.

    string isim1 = null ;
    Console.WriteLine( isim1 ??= "merhaba");    ---> ??= operatörü kullandığımız için null olan değere karşılık "merhaba" ifadesi ekrana basıldı.
    Console.WriteLine(isim1);                   ---> ??= operatörü kullandığımız için null olan değere karşılık "merhaba" ifadesi ekrana basılacak.


    örnek :

    int? id = null;                             ---> normal şartlarda int null almaz, ? operatörü yardımı ile nullable özelliği kazandırdık.
    Console.WriteLine(id ?? 1);                 ---> ?? operatörü kullandığımız için null olan değere karşılık 1 ifadesi ekrana basıldı.
    Console.WriteLine(id);                      ---> ?? operatörü kullandığımız için kodun devamındaki çağırmalarda 1 yazmayacak.

    int? id = null;                             ---> normal şartlarda int null almaz, ? operatörü yardımı ile nullable özelliği kazandırdık.
    Console.WriteLine(id ??= 1);                ---> ??= operatörü kullandığımız için null olan değere karşılık 1 ifadesi ekrana basıldı.
    Console.WriteLine(id);                      ---> ??= operatörü kullandığımız için kodun devamındaki çağırmalarda 1 yazacak.
/// akış kontrol mekanizmaları

    1- switch - case metodu

    2- if -elif - else metodu
    ..
    .
    .
    .
    