Derleme : c# kodlarını assembly tarzı sadece bilgisayarın anlayabileceği dillere çevirme işlemidir.

Beşeri seviyede algılanabilen dillere yüksek seviyeli diller denir. c# orta seviye bir dildir. 

çok yüksek seviyeli diller ;

Visual Basic , VB.Net , Foxpro , Access...

Yüksek seviyeli diller ;

Pascal ,  Basic , Fortran...

Orta seviyeli diller ;

C , C++ , C# , Java , ADA...

Düşük seviyeli diller ; 

assembly...

Makine dilleri ;

1 veya 0 lardan oluşur.


C# ile neler yapılabilir,

1- Web uygulamaları,
2- Mobil uygulamaları,
3- Web Servisleri,
4- Servis Mimarileri,
5- consol uygulamaları,
6- .dll uzantılı dosyalar,
7- Windows form uygulamaları,
8- oyunlar,
9- ERP, Muhasebe, Multi Media, İstatistik, Güvenlik Yazılımları...


.net microsoft tarafından yazılım geliştiriciler için geliştirdiği teknolojileri sunduğu bir çatıdır.
microsoft işletim sistemleri için de teknoloji sunarlar ancak bu teknoloji son kullanıcılar içindir.

.net çatısı altındaki paket yayınları şuan .net 8.0 paketi yayında.

.net bir developer'a lazım olabilecek bütün platformlar vardır. mobil, gaming, desktop.....

.net framework ile .net core arasındaki fark nedir?

.net framework da her platformda geliştirme yapabiliyoruz ancak sadece windosw işletim sistemine çalıştırabiliyoruz.
.net core da ise her platformda geliştime yapabiliyoruz ve her platformda da çalıştırabiliyoruz.

.net core modüler bir yapıya sahiptir.
.net core ilk sürümü .net 5.0 dır.

C# .net core çatısı altında yayınlanan teknolojilerden birisidir.

derleme nedir ? 

bir uygulama dili derlenen bir dil ise önce derlenir sonra çalıştırılır. (derlemek=makine diline çevirmek)

derlenen diller;

C , C++ , C#

yorumlanan diller ;

Python, JsvsScript, Ruby, PHP, Perl

Derleme sonucu ilgili dosyada 2 şekilde dosya oluşur. 

1- .exe uzantılı dosya 
2- .dll uzantılı dosya
bu dosyalar derleme sonucu oluşan ve son kullanıcıya ulaşan dosya uzantılarıdır.


Microsoft Visual Studio ;

microsoft tarafından geliştirilmiş ve .net mimarilerinin tamamını kodlayabileceğimiz bir platformdur.

en çok kullanılanlar ;

debug       : kontrollü çalıştırma,
nuGet       : peket yükleme,
ErrorList   : Hata Listeleme

proje oluşturma nasıl yapılır.

proje      : içerisinde amaca uygun çözüm geliştirilen operasyonların yürütüldüğü bir bölümdür.
solution   : içerisinde bir veye birden fazla proje barındırabilen evrensel bir kümedir.


gerçek hayatta bir uyglama yazarken bu uygulama bir proje değil bir solution dur. 
bu solution birden fazla projenin birleşimi olabilir.


Visual Studio Code ile proje oluşturma ve derleme;

- create new project ile proje başlatılır.
- en basit uygulama console uygulamasıdır.
- solution name ile project name aynı olmak zorunda değildir.
- bir solution a birden falz proje eklemek istersek solution üzerine sağ tık yaparak Add/New project diyebiliriz.
- Derleme işleminden sonra oluşan bin klasörü altında yer alır.
- derleme sonucu : .deps.json, .dll, .pdb, .runtimeconfig.json uzantılı dosyalar oluşur.
- .net 6.0 ve .net 7.0 da da aynı dosya uzantıları mevcuttur.



Visual Studio Code , Visual Studio ya nazaran daha hızlı kod yazmaya yarar.

VS Code avantajları , 

- kendinde dahili bir komut satırı barındırır.
- komut satırında CLI adını verdiğimiz herhangi bir arayüzü olmayan bir asistan mevcuttur.

en yaygın kullanılan CLI komutlar:

ls : mevcut dizindeki dosya ve dizinleri listeler,
cd : dizinleri değiştirmemize yarar. 
pwd : şuanki dizinin yolunu gösterir.
mkdir : yeni bir dizin oluşturur.
touch : yeni bir dosya oluşturur veya oluşturulan dosyanın tarihinü günceller.

cp : dosyaları koplayalar,
mv : dosyaları taşır veya yeniden isimlendirir.
rm : dosyaları veya dizinleri siler 
cat: dosyaları birleştirir ve içeriklerini görüntüler
more veya less: uzun metin dosyalarını sayfa sayfa görüntüler.

- dizin ve dosya işlemleri :
grep : belirli bir metini dosya içerisinde arar.
find : dizinler arasında dosya arar.
chmod : dosya ve dizinlerin izinlerini değiştirir.
chowm : dosya ve dizinlerin sahiplerini değiştirir.

- ağ işlemleri : 
ping : bir IP adresini veya alan adını belirtilen sayıda paket gönderir ve yanıtları görüntüler,
ifconfig ve ip : ağ arayüzünü ve IP bilgilerini görüntüler,
ssh : uzak sunuculara güvenli bir şekilde başlanmamızı sağlar,

- paket yönetimi : 
apt-get : debian tabanlı işlemler için paketleri yinetir,
yum : red hat tabanlı işlemler için paketleri yinetir,
brew : macos tabanlı işlemler için paketleri yinetir,

-sistem bilgileri :
top veya htop : sistem kaynaklarını ve çalışan işlemleri görüntüler.
df : disk kullanımını gösterir.
free : bellek kullanımını gösterir.
uname : sistem bilgilerini gösterir.

- kullanıcı ve izinler ;
who veya w:aktif kullanıcıları ve oturum bilgilerini görüntüler,
useradd : kullanıcı ekler,
userdel : kullanıcı siler,
passwd : kullanıcı parolasını değiştirir.
sudo : yönetici veya süper kullanıcı haklarıyla komut çalıştırır.

- metin işlemleri :
echo : metin çıktısı üretir.
grep : metin içerisindeki desen eşleştirmeleri yapar.
sed : metin düzenlemesi yapar.


dotnet CLI ile proje oluşturma:

dotnet CLI ile proje oluştururken içerisinde bulunduğumuz komuta dikkat etmemiz gerekir.
dotnet CLI yı çağırmak için terminal ekranına 'dotnet' yazmamız yeterlidir.
dotnet --help ile dotnet üzerinden yapabileceklerimizi listeleyebiliriz.

uygulama başlatmak için ;

dotnet new (buraya uygulama tipini yazıyoruz) --name (buraya uygulama ismini yazıyoruz)

başlattığımız uygulamayı derleyebilmek için ;

dotnet build.


// dotnet CLI nedir?

Visual Studio idesinde kendi yaptığımız işlemleri komut satırı ile yapabilmek için CLI isimli asistandan aracılı ile yapabiliriz.


// dotnet CLI komutları nelerdir?

1- help : dotnet CLI tarafından desteklenen komutlar hakkında ayrıntılı bilgi veren kokmuttur. ( dotnet help)

2- new  : dotnet CLI üzerinden proje oluşturmaya yardımcı olan komuttur. (dotnet new (proje tipi) --name (proje ismi))

not : sadece dotnet new yazıp enter tuşuna bastığımızda hangi proje tiplerini oluşturabileceğimiz konusunda CLI bize yardımcı olur.

not: aynı isimde farklı bir dosya olmasından kaynaklı olarak oluşacak hatalarda (dotnet new (proje tipi) --name (proje ismi)) --force
şeklinde satırın sonuna force keyword unu kullanırsak hata almadan işlemi yapabiliriz.

3- restore : proje sürecinde referans edilen yahut referansı kaldırılan paketlerin restorasyonunu sağlar. (dotnet restore)

referans mantığı nedir ? 

bir yazılım geliştirme sürecinde işlemleri / iş mantıklarını genellikle kah kendimiz tarafından kah başkaları tarafından (ki genelde başkaları tarfından)
önceden yazılmış kütüphanelerin desteğini alarak çözmeye referans mantığı denir.

restore edilen paketler nuGet ten gelir.

4- build : projeyi ilk önce restore eder ve sonrasında derler. sonuç olarak .exe ve .dll çıktıları verir. 
bu .dll ve .exe uzantılı dosyalar /bin/Debug/net7.0 dizininde görüntülenir.

not : proje derlemeden önce muhakkak restore edilir.


5- publish : projeyi derleyerek yayınlanabilir dosyaların oluşmasını sağlar. çıktılar /bin/Debug/net7.0/publish dizininde bulunur.

publish klasörü altında : 

.dll,
.deps.json,
.runtimeconfig.json,
.uygulama bağlantılarının .dll dosyaları

bulunur.

not : uygulamaya ait algoritmaları yayınlamak istemiyor olabiliriz, böyle bir durumda publish komutu bize yardımcı olur.
not2: publish dosyalarında herhangi bir güncelleme yapılamaz, yapılan değişikliklerden sonra tekrar oluşturmak gerekir. çıktı almak gibi...

6- run : uygulamayı derler ve ayağa kaldırır. (dotnet run ) 

not : dotnet run --no-build uyulamayı derlemeden ayağa kaldırır.


// proje modifikasyon komutları:

proje seviyesinde işlem yapmamızı ve referans ekleyip çıkarmamızı sağlayan komutlardır.

paket / kütüphane : nuGet havuzundan gelir,
referans          : önceden yazılmış .dll uzantılı dosyalardır.
.exe uzantısı     : yazdığımız uygulamayı bir insan kullanacaksa bu uzantıda olur.
.dll uzantısı     : yazdığımız uygulamayı bir yazılım kullanacaksa bu uzantıda olur.

1- add package : uygulamaya nuGet'den paket / kütüphane yüklememizi sağlar.

dotnet add package (paket ismi)  / ile terminalden paket yükleyebiliriz.

2- add referance : uygulamaya fiziksel bir .dll uzantılı dosya referans etmemizi sağlar.

diyelimki solution unumuzda birden fazla uygulama var ve bu uygulamalar birbirlerini referans etmek zorundalar.
örneğin veri tabanı işlemlerini bir uygulama aracılığı ile yapıyoruz , iş mantığını / ana olayların cereyan ettiği olayları 
başka bir uygulama ile yapıyoruz. ana olayların cerayan ettiği uygulamaya veri tabanı işlemlerinin yapıldığı uygulamayı
referans etmek zorundayız.

dotnet add referance (referasn edilen ana dosya).csproj referance (referans eden ufak dosya).csproj

3- remove package : uygulamada add package ile yüklediğimiz paketleri/kütüphaneleri silmeye yarar.

dotnet remove package ( package ismi)

4- remove referance : uygulamaya referans edilmiş dll dosyalarını kaldırmaya yarar.

dotnet remove referance (referans ismi)

list referance : uygulamda referans edilen tüm paketleri / kütüphaneleri listeler.

dotnet list referance 

n adet uygulamanın olduğu bir solutionda çalıştığımızı varsayalım . 
hangi uygulamanın hangi paketlerin/kütüphanelerin referans edildiğini kodlara bakmadan 
bu yöntemle öğrenebiliriz

// programlamaya başlarken temel ilkeler:

yeni çıkan her dil bir gelenek ve bir kabul ile yola çıkar. bunlara ilke diyoruz.

ilke-1 : don't repeat your self 

bir kod inşa edilirken kullandığımız dile ait bütün özellikleri bildiğimizi varsayalım ,
aynı kod parçasını birden fazla yerde aynı yöntemle kullanırsak bu 1.ilkeye aykırı bir davranış olur. 
günün birinde uygulamada tekrar eden kod parçalarında değişiklik yapmak istersek tek tek bütün kopyalarını bulmamız gerekir.
bir algoritmayı öğrenerek birden fazla problemde aynı algoritmayı kullanmak 1.ilkeye uymaz.

tecrübeden faydalanmak yaratıcılığı öldürür.

ilke-2 : anlamlı isimlendirme,

isimlendirme yaptığımızda anlamlı ve çağırışım yapan isim vermemiz gerekir.

// main fonkiyonu nedir ? 

bir uygulama içerisinde muhakkak olması gereken bir fonksiyondur.
program.cs dosyası uygulamanın başlangıç dosyasıdır ve başlangıç kodları burada bulunur.

not : .cs uzantılı dosyalar c# dilinde yazılmış dosyalarıdır.

başlangıç kodlarından kastımız nedir ?

uygulama ayağa kalktığında işletim sistemi ile iletişim kurabilecek fonksiyonun 
ve bu fonksiyon içerisinde başlangıca dair komutları barındıracak bir yapıdır.

not : işletim sistemi ile sadece program.cs dosyası içerisindeki main fonksiyonu iletişim kurabilir.

main fonksiyonu kuralları : 

1- main fonksiyonu uyglamaya özgüdür ve her projede yanlızca 1 adet olur.
2- aynı uygulama içerisinde 2.bi main fonksiyonu yoktur.


işletim sisteminden parametre ile console'a değer yazdırabiliriz.

static void Main(string[] args)
{
    Console.WriteLine("Hello World!");
    Console.WriteLine(args[0]);
    Console.WriteLine(args[1])
}

terminalden dotnet run sedat mengü yazdığımızda çıktı ekranına ;

Hello World!
sedat
mengü

// top level statement nedir ? 

C# 9.0 ile gelmiştir.

// yorum satırları ve region özelliği : 

// tek satırlık yorumlarda kullanılır.

/*
çok
satırlık
yorumlarda
kullanılır
*/

region : kod dosyasını kategorik hale getirebilemizi sağlayan bir ön işlemci komutudur. 

developerların yazdıkları kodların daha net görebilmelerine yardımcı olur.

#region A operasyonu
    Console.WriteLine("Hello, World!");
    Console.WriteLine(typeof(char).IsPrimitive);
    Console.WriteLine(typeof(sbyte).IsPrimitive);
    Console.WriteLine(typeof(byte).IsPrimitive);
    Console.WriteLine(typeof(short).IsPrimitive);
    Console.WriteLine(typeof(ushort).IsPrimitive);
    Console.WriteLine(typeof(int).IsPrimitive);
    Console.WriteLine(typeof(uint).IsPrimitive);
    Console.WriteLine(typeof(long).IsPrimitive);
    Console.WriteLine(typeof(ulong).IsPrimitive);
    Console.WriteLine(typeof(float).IsPrimitive);
    Console.WriteLine(typeof(double).IsPrimitive);
    Console.WriteLine(typeof(decimal).IsPrimitive);
#endregion

#region A operasyonu

// todo özelliği : (editorun sağlamış olduğu bir özelliktir.)
kodun içerisinde yazılan notlara bir liste aracılığı ile ulaşmaya yarar. 

todo listesi genelde takım çalışmalarında hangi takım çalışanının müdahale etmesi istenirse o kişiye atıfra bulunulmak için kullanışlıdır.

todo listelerine erişmek için;

vs de görünüm/görevler penceresinden ulaşabilirz.
vscode da ise sol taraftaki çubukta 'source control' alanı içerisinden ulaşabiliriz.



// debuging :

projenin her aşamasında en çok kullandığımız özelliklerdendir. platform ve teknoloji farketmeksizin her noktada kullanılır.

brekapoint kavramı ;

debug işleminde hassas olan satıra koyduğumuz ve debuging esnasında durduğumuz noktadır. 
debug modda 1 adım ilerlemek için F10 tuşuna basaır. her basışımız uygulamanın bir adım daha ilerlemesini sağlar.

F5 ile debug modu salmış oluruz ve uygulama sona kadar gitmiş olur.

watch penceresi nedi ? 

debug modda çalıştırma esnasında bazı değişikliklerin değerlerini izlemek isteyebiliriz. 
debug çalışırken izlemek istediğimiz değişkenin üzerine tıklayarak 'izleme ekle' seçeneğini seçerek 
watch penresesine eklemiş oluruz.

peki debuguz uygulamayı çalıştırmak nasıl olur?

debug zaman ve performasn açısından maliyetli bir yoldur. genelde projemizden emin olduğumuz durumlarda debugsuz çalıştırabiliriz.



// değişkenler nelerdir ?

değişkene neden ihtiyaç duyarız.

amaç : elimizdeki verileri doğru yazılımlar ile doğru bir şekilde işleyerek doğru sonuçları elde etmektir.

yazılım herhangi bir veri tutmaz , işlem gerçekleştiği esnada veriler RAM'da tutulurlar , oradan alınır, kullanılır , ve geri yerine konur...

işte bu noktada değişkenleri RAM'de tutabilmek için değişkenleri kullanılırız. 

veri tabanındaki verileri direkt olarak işleyemeyiz, değişken yardımı ile RAM'den alıp değiştirip geri yerine koyarız.

önemli not: iş yapıyorsak RAM'de çalışmalıyız.

tanım : yazılımda işlenecek veriyi yazılım adına RAM'e yerleştirebilmek için biz developerlar değişkenleri kullanırız.

value type ve primitive type nedir ?

C# dili yapısı gereği RAM'e yerleştireceğimiz veri türünü bilmek ister ki ona göre bir alan tahsisinde bulunsun.

. bir değişkenle RAM'de alan tahsisinde bulunulduğunda buna 'değer türlü değişken' ( value type) deriz. yaş,boy,isim,trih vs...
. birden fazla farklı tipte değişken barındırabilen yapılara 'referans türlü değişken' deriz.

ad : "ali"; -- değer türlü değişken
soyad:"uzun"; --değer türlü değişken
yas=23; --değer türlü değişken
kanGrubu='a' -- değer türlü değişken

yukarıdaki bilgilerin tamamı paket olarak da referans türlü değişken olarak tanımlanır.

tanım : sadece bir tür değer tutan değişkenlere değer türlü değişken denirken, birden faza değişik türde değişken tutabilen türlere referans türlü değişken denir.

primitive type : ham veri , türetilmemiş veri anlamında kullanılır ve en ilkel türdür. (byte)

not : RAM'de değişken için alan tahsis edileceği zaman değişkenin türündne hareket edilir ve hangi türde değişken tanımlandıysa o türde değişken barındırılır.
string ile tahsis edilen alana double türünde bir veri barındıramazsınız , veya char türünde bir alan tahsisinde bulunduysanız int türünde bir değer barındıramazsınız. barındırtmazlar :)

veri türleri :

bool : true veya false tutabilir.   (1 bit )

char : tek karakter tutabilir.   (16 bit )

sbyte : -128 ile +127 arasındaki değerler tutabilir.   (8 bit )

byte : 0 ile +255 arasındaki değerler tutabilir.   (8 bit )

short : -32768 ile +32767 arasındaki değerler tutabilir.   (16 bit )

ushort : 0 ile 65535 arasındaki değerler tutabilir.   (16 bit )

int : -2147483648 ile +2147483647 arasındaki değerler tutabilir.   (32 bit )

uint : 0 ile +4294697295 arasındaki değerler tutabilir.   (322 bit )

long : -9233372036854775808 ile +9233372036854775807 arasındaki değerler tutabilir.   (64 bit )

ulong : 0 ile +18446744073709551615 arasındaki değerler tutabilir.   (64 bit )

float : +- 1.5 x 10(-45) ile +-3.4x10(38) arasındaki değerler tutabilir.   (32 bit )

double : +- 5x10(-324) ile +-1.7x10(308) arasındaki değerler tutabilir.   (64 bit )

decimal : +-1.5x10(-28) ile +-7.9x10(28) arasındaki değerler tutabilir.   (128 bit )

string : metinsel ifadeleri tuttuğumuz değişken türüdür ve referans tiplidir.


yukardaki türlerden sadece 'decimal' primitive değildir , geri kalan türlerin tamamı primitive dir.

bir türün primitve olup olmadığını nasıl kontrol edebiliriz.


Console.WriteLine(typeof(bool).IsPrimitive);
Console.WriteLine(typeof(char).IsPrimitive);
Console.WriteLine(typeof(sbyte).IsPrimitive);
Console.WriteLine(typeof(byte).IsPrimitive);
Console.WriteLine(typeof(short).IsPrimitive);
Console.WriteLine(typeof(ushort).IsPrimitive);
Console.WriteLine(typeof(int).IsPrimitive);
Console.WriteLine(typeof(uint).IsPrimitive);
Console.WriteLine(typeof(long).IsPrimitive);
Console.WriteLine(typeof(ulong).IsPrimitive);
Console.WriteLine(typeof(float).IsPrimitive);
Console.WriteLine(typeof(double).IsPrimitive);
Console.WriteLine(typeof(decimal).IsPrimitive);

örnek : 1000 değerini short , ushort , int , uint , long , ulong , float , double , decimal türlerinin tamamı ile tutabiliriz.
ancak yer proje optimizasyonu için en makul aralık olan short veya ushort u kullanmamız gerekir.

// C# dilinin temel kuralları : 

1- bütün kodlar main fonksiyonu içerisine yazılır.
2- { } bu yapı scope olarak değerlendiril (faliyet alanı)
3- C# BÜYÜK ve küçük harf duyarlılığna sahiptir. "ahmet","Ahmet","AhMet","AHMET" tamamen ayrı şeklerdir.
4- C# dili tip güvenliği olan bir dildir. 

değişken tanımlama;

degisken_turu degisken_adi;

bu şekilde ilk yazılacak olan değişkenin türüdür 2 yazılacak olan değişkenin anlamlı ismidir. (anlamlı olması 2.ilke)

örnek:

string adi;  --> bu şekilde RAM'de "adi" isminde string bir alan rezervasyonu yapılmış oldu. 
int yas ; --> bu şekilde RAM'de "yas" isminde integer bir alan rezervasyonu yapılmış oldu. 

ram yapısı : 

stack ve heap ram da kullandıığımız 2 alanın adıdır.

stack : içerisinde değer türlü değişkenlerin;

değişken türünün , 
değişken adının,
değişken değerininin,
metot/fonksiyon isimlerinin,

tutulduğu bir bölümdür.

heap : nesnelerin tutulduğu bölümdür.

not : stack içerisinde tutualn değişken ismine nadiren de olsa 'referans' dendiğini görebilirsiniz.
not : stack alanıda değişkene herhangi bir değer ataması yapılamasa dahi yer tahsisi yapılır.
not : metotların/fonksiyonların bellek adresleri de stack de tutulur.

metotları / fonksiyonları çağırmak üzere oluşturuyoruz ve bu metotlar/fonksiyonlar isim üzerinden çağırırız ve bu isimde denk gelen adres stack alanında tutulur.


değişken tanımlana kuralları:

değişken isimleri ilerleyen süreçte developer açısından karışıklığa mahal vermemek için anlanlı olmalıdır.
değişken isimleri . ' , gibi özel karakterler barındırmamalıdır. _ istisnadır.

1sayi olmaz , sayi1 olabilir.
ad? olmaz , ad olabilir,
stok.adedi olmaz , stok_adedi olabilir.

not : aynı scope içerisinde aynı isimde birden fazla değer tanımlanamaz.

isimlendimre gelenekleri ;

1- snace_case ; tük hrafler küçüktür ve kelimelerin arasına _ konur.

. kullanici_adi;
. isim_soyisim;
. personel_giderleri;

2- Pascal Name : her kelimenin ilk harfi büyük yazılır. klaltmalar özellikler büyük harf ile yazılır.

. AdSoyad;
. TcKimlikNo;
. Satislar;
. DogumTarihi;
. InOut = IO,
. InOutStream = IOStream;

3- camelCase : sadece ile kelimenin ilk harfi küçük yazılır, takip eden kelimelerin ilk harfleri her zaman büyük yazılır.

. satisDurumu;
. personeAdi;
. orderId;
. userNAme;
. userNAmePassword;

değişken isimlerinde @ operatörü : 

string x şeklinde bir değişken tanımlayabildiğimiz gibi string @x şeklinde de tanımlama yapabiliriz. 
ancak ahm@t gibi @ karakteri ismin ortasına kullanılırsa özel karaktere girer ve kabul edilmez.

static , for , if , string , int gibi programa özgü kelimeleri @ ilavesi ile değişken ismi olarak kullanabilirz.

string @string ,
int @int , 
double @double , 
string @static vb.

tanılanmış değişkene değer atama : 

int x ; şekilde herhangi bir değer ataması yapmadan da değişken tanımlayabildiğimiz gibi int x=5; gibi tanımlanmış değişkenlere de tekrardan değer atayabiliriz.

burada dikkat edilmesi gereken şey, bir değere en son atanan değer geçerlidir.

değişeken değer atama kuralları ;

değer türleri : 

1- metinsel değerler ; string keywordu ile tutulur, "..." içerisine yazılmalıdır. "gencay" , "12345678901" vb.

not : bir sayısal ifade "..." arasında metinsel bir biçimde tutuluyor ise herahngi bir matematiksel işleme kapalıdır.

2- karaktersel değerler: char keywordu ile tutulur , '...' içerisinde yazılırlar. 'a' , 'b' vb.

not : 'ab' şeklide birden fazla karakter barındırması durumunda program bu noktada hata verecektir.

3- mantıksal değerler : bool keywordu ile tutulur. true ya da false değerleri alabilir.

not : "True" ile true aynı şey değildir.

4- sayısal değerler : int,short,long,decimal .... gibi keyword ler ile tutulurlar. herhangi bir tırnak kullanmayız.

not : sayısal ifadeler varsayılan olarak int türündedirler.

5- ondalıklı değerler : float , double ve decimal keywordu ile tutulurlar. 

not : tüm ondalıklı sayılar tamsayıları karşılayabilirler.

a- float : bu türde bir değişkene değer ataması yapılırken değerin sonuna f veya F ifadesi eklenmelidir.

float @float = 3.14f , float @float2 = 3.15F vb.

b- double : bu türde bir değişkene değer ataması yapılırken değerin sonuna d veya D ifadesi eklenmelidir.

double @double = 3.16d veya double @double2 = 3.17D vb.

c- decimal : bu türde bir değişkene değer ataması yapılırken değerin sonuna m veya M ifadesi eklenmelidir.

decimal @decimal = 3.17m veya decimal @decimal2 = 3.19M vb.


not : ondalıklı türlerde bir değer default olarak double dır. (sonuna d veya D gelmesi gerekir.) default olduğundan dolayı değerin sonuna d ve D koymasak da olur.

not : char türünde bir değişken tanımlayacak isek "..." şeklinde çift tırnak kullanamayız.
not : string türünde bir değişken tanımlayacak isek '...' şeklinde tek tırnak kullanamayız.

tuple türünde veri atama : 

tuple : tek bir syntax üzerinde birden fazla değişken tanımayabilmemizi sağlayan bir nesnedir.

not : tuple değişken içerisinde int, string , double , vs olmak üzere birden fazla aynı veya farklı türde değişken tanımı mevcuttur.

(int a, string b) @tuple = (5,"kemal");

literal düzenleme : int x = 1000000; şeklinde gösterimi int x=1_000_000; şeklinde de gösterebiliriz.


// değişken türüne uygun default değer atama;

tüm değişkenlerin bir default değeri vardır. 

not : main fonksiyonu içerisinde tanımlanan bütün değişkenlerin default değerleri otomatik olarak atanmaz,
class içerisinde tanımlanan fonksiyonların değerleri default olarak atanır.

varsayılan değerler : 

bool : false,
sayısal : 0,
char = '0',
strign = null

main içerisinde bu deperler otomatik olarka gelmez class içerisinde tanımlanan değerlerde otomarik olarak gelir.

main scopu içerisinde default değeri atamak için,

bool x = default;

Console.WriteLine(x);

console a False değeri yazılır.

// tanımlanmış bir değerin değerini okuma :

int x = 5;  // (integer türünde x adında bir alan tahsis edildi ve içerisine 5 değeri atandı.)

int y = 10;  // (integer türünde y adında bir alan tahsis edildi ve içerisine 10 değeri atandı )

int z = x ;  // (integer türünde z adında bir alan tahsis edildi ve içerisine x (yani 5 değeri) atandı)

z = y ;  // (daha önce z adını alan ve türü belirtilen bir alan tahsis edildiğinden herhangi bir hata oluşturmadan z değişkenine y ( yani 10 değeri) atanır.)

b = x ;  // (daha önce b adında bir değişken adı ve türü belirtilmediği için bu kod satırı hata verecektir.)


RAM'da alan tahsis edilirken 2 kritik vardır. bunlardan bir tanesi eksik olursa değişken tanımlanamaz.

1- veri tipi ( int , string, bool, char vb.)
2- değişken ismi ( isim , numarala, sira , sayi vb.)


önemsiz not : int a = 5; a = a ; dediğimizde herhangi bir hataya sebebiyet vermez. bir değişkene aynı türde aynı değeri saklaması için verebiliriz.


// değeri olmayan değişkenler. 

main içerisinde atanmış bir karşılığı olmayan değer ile ( int x ;) hiç bir şey yapamayız. 
çünkü burada uygulamaya int türünde ve x isminde bir alan tahsis edeceğiz dedik ve main yapısı gereği default değer atamaz.
ancak bu (int x;) ataşmış karşılığı olmayan bir değişkeni class içerisinde kullanabiliriz. default değerler otomatik atanır.



// değişken davranışlarına genel bakış , 

bir değişkenin kendini göndermek ile değerini göndermek arasında fark vardır. 
değerini göndermek şu şekilde olur.

int x = 9;  // (burada stack alanında int türünde x adında içerisinde 5 değerinin tutulduğu bir alan tahsisi yaptık.)
int y = x;  // (burada stack alanında int türünde y adına içerisnde x in değerinin tutulduğu bir alan tahsisi yaptık.) x in kendisini atmadık , değerini tanımladık.
y = 20;  // (burada stack te barındırılan y değişkenine 20 değerini atadık. x değişkenine herhangi bir şey olmadı.)

Console.WriteLine(y);  // 20 


// değişkenlerin faliyet alanları : 

scope : değişken ve fonksiyonların sınırlarını belirler. tanımlamalarda ve algoritmik çalışmalarda karışıklığı önler.

{ } --> scope 


not : bir scope içerisinde tanımlanan değişkene o scope içerisinde tanımladığı satırdan sonra herhangi bir yerden erişebiliriz.
iç içe tanımlanan scope larda en dışta tanımlanan scope daki değişkene en içteki scope dan erişebiliriz ancak tersi mümkün değildir.


scope lar nerelerde kullanılır;

1- namespace , classlarda , metotlarda , döngülerde , if yapısında scope kullanılır.
2- herhangi bir keyword e bağlı kalmadan da scope oluşturabiliriz.


// değişmezler.

sabitlere neden ihtiyaç duyarız?

- bazen sabit değerler ile de çalışmamız gerekebilir. 
sabitlerin asıl amacı bir başka yazılımcı tarafından değiştirilmesini istemediğimiz durumlarda kullanırız. bir diğer avantajı ise
kendi hatalarımızın önüne geçmektir. dalgınlıkl değiştirmememiz gereken bir noktada deişmemesi gereken bir değeri değiştirebiliriz.

development aşamasında 'sabit' olarak tanımlanmayan bir değer değiştirilirse hehrangi bir hata ile karşılaşmadan compiler işlemi tamamlanır.
en erken uygulama çıktılarını görüntüleme aşamasında mantıksal hatalar olduğunu anlayabiliriz. bu noktadan sonra hatanın yerini tespit etmemiz birhayli uzun sürecektir.

sabitleri nasıl tanımlayabiliriz ? 

- const keywordu ile tanımlarız.

prototip olarak değişkenlere çok benzer ancak davranışsal olarak değeri bir daha değiştirilemez. değiştirme aşamasında hata mesajı alırız.
özünde staticdir.

static nedir ? 

- static uygulama bazlı veri depolayabildiğimiz bellekte bir alandır.

- scope içerisinde tanımlanan bir değişken gene sadece aynı scope içerisinden erişime izin verir, static'e konulan bir değer / değişken evrenseldir ve uygulamanın herhangi bir yerinden erişime açıktır.

static ile const arasındaki fark nedir ? 

- static değişkendirler , const'lar değişmezdirler.

readonly : sadece okunabilir değişkenler tanımlanmaktadır.

const tanımlandığı anda değer ataması yapılmak zorundadır. alan tahsis edeyim, ileride bu alanı dolduracağım olmaz.

readonly de ise const'a ilave olarak constructure da da değer ataması yapabiliriz. 3.bi değer ataması yapamayız, bir defa değer ataması yapınca değiştiremeyiz.

readonly static değildir.

const değişken tanımlama : 

int a = 5 ;         // (bu şekilde int türünde a adında içerisinde 5 rakamının tutulduğu alan tahsis ettik ama kapı her zaman açık)

a = 8;              // (bu şekilde a değişkenine giderek değiştirebiliriz.)

const int b = 7;    // (bu şekilde int türünde b adında içerisinde 7 değerinin tutulduğu alan tahsis ettik ve const ile kapıyı kilitledik.)

b = 11;             // (const ile kapıyı kiltlediğimizden dolayı b değeri üzerinde değişiklik yapamayız.)



// global ve local değişkenler , 

bir değişken konumlandığı yere göre locak veya global diye isimlendirilirler. yapı ve işleyişte herhangi bir değişiklik olmaz sadece isimlendirme yapılmıştır.

class scope u içerisinde tanımlanan değişkenlere global değişken denir.
metotlar içerisinde tanımlanan değişkenlere local değişlen denir.


// değişken tanımlama varyasyonları: 

1- int a; veya int a = 5;   // klasik varyasyon

2- aynı türde birden fazla değişken oluşturulması gereken durumlarda kullanılabilir.
int x = 3, y= 4, z=5; --> alan tahsis ettik ve değer atamsı yaptık.
int x,y,z;  --> alan tahsis ettik ve değer ataması yapmadık.

// değişkenler arası değer atama.

1- deep copy : eldeki veri klonlanır. 1 iken 2 veri oluşur.

not : değer türlü değişkenler birbirine atanırken default olarak deep copy geçerlidir. yani veri otomatik olarak türetilir.

int a = 7;  ---> (stack alanında int türünde a isminde 7 değişkenini tahsis ettik.)
int b = a;  ---> (stack alanında int türünde b isminde a değişken (değerini deep copy olarak) tanınladık. )
b = b * 3;  ---> (deep copy olarak kopyaladığımız a değişken değeri değişmeden b üzerinde matematiksel işlem yapabiliriz.)

Console.WriteLine(a);  // 7
Console.WriteLine(b);  // 21 

b değişkeni a değişkeninden deep copy copyalandı ve sonrasında a değişkeni bu kopyalamadan etkilenmeyecektir.

2- shallow copy :  birden fazla referansla işaretlemeye dayalı kopyalama yöntemidir.

bellekte birden fazla referansın tek bir veriyi işaret etmesidir.

neticede ilgili değer bir değişikliğie uğradığında tüm işaretleyen referanslara da bu değişiklik yansıtılacaktır. (Autocaddeki blok editor mantığı)

A ve B değişkenleri heap daki aynı değeri kullanıyorlar, heap daki değer değişirse A ve B bu durumdan etkilenecek.

not : değer türlü değişkenlerde bilinçli olarak shallow copy yaptırılabilir. 

not2 : nesne ve referans arasındaki ilişkide varsayılan davranış olarak kabul edilmektedir.

// object türü : 

tüm türleti karşılayabilen , referans türlü ve stack de tutulmayan bir türdür.
object olarak tanımlanan değişkenler şeffaf bir kutu gibi içerisinde tutulmuş gibidir. object içerisinde herhangi bir türde , tür değişmeden tutulur. (boxing özelliği)


boxing özelliği : 

object bir değişkene herhangi bir türdeki değer türünde bir değişikliğe uğramadan göndermektir. boxing işlemi neticesinde ilgili değer object in içerisinde kendi türünde saklanır.

object türünde tutulan hangi tür veri olursa olsun o türde bir işleme tabi tutulamaz. int ise matematiksel olarak işlem yapılamaz, string ise metinsel işlemler yapılamaz.

boxing işlemini şeffaf bir kutu olarak düşünebiliriz. içerisi görünüyor ancak işlem yapmaya kapalı.

şeffaf kutulama olarak adlandırdığımız boxing de tutulan değişkeni işlem yapılabilir hale getirmek için unboxing işlemi yapmak gerekir.


