Derleme : c# kodlarını assembly tarzı sadece bilgisayarın anlayabileceği dillere çevirme işlemidir.

Beşeri seviyede algılanabilen dillere yüksek seviyeli diller denir. c# orta seviye bir dildir. 

çok yüksek seviyeli diller ;

Visual Basic , VB.Net , Foxpro , Access...

Yüksek seviyeli diller ;

Pascal ,  Basic , Fortran...

Orta seviyeli diller ;

C , C++ , C# , Java , ADA...

Düşük seviyeli diller ; 

assembly...

Makine dilleri ;

1 veya 0 lardan oluşur.


C# ile neler yapılabilir,

    1- Web uygulamaları,
    2- Mobil uygulamaları,
    3- Web Servisleri,
    4- Servis Mimarileri,
    5- consol uygulamaları,
    6- .dll uzantılı dosyalar,
    7- Windows form uygulamaları,
    8- oyunlar,
    9- ERP, Muhasebe, Multi Media, İstatistik, Güvenlik Yazılımları...


.net microsoft tarafından yazılım geliştiriciler için geliştirdiği teknolojileri sunduğu bir çatıdır.
microsoft işletim sistemleri için de teknoloji sunarlar ancak bu teknoloji son kullanıcılar içindir.

.net çatısı altındaki paket yayınları şuan .net 8.0 paketi yayında.

.net bir developer'a lazım olabilecek bütün platformlar vardır. mobil, gaming, desktop.....

.net framework ile .net core arasındaki fark nedir?

.net framework da her platformda geliştirme yapabiliyoruz ancak sadece windosw işletim sistemine çalıştırabiliyoruz.
.net core da ise her platformda geliştime yapabiliyoruz ve her platformda da çalıştırabiliyoruz.

.net core modüler bir yapıya sahiptir.
.net core ilk sürümü .net 5.0 dır.

C# .net core çatısı altında yayınlanan teknolojilerden birisidir.

derleme nedir ? 

bir uygulama dili derlenen bir dil ise önce derlenir sonra çalıştırılır. (derlemek=makine diline çevirmek)

derlenen diller;

C , C++ , C#

yorumlanan diller ;

Python, JsvsScript, Ruby, PHP, Perl

Derleme sonucu ilgili dosyada 2 şekilde dosya oluşur. 

1- .exe uzantılı dosya 
2- .dll uzantılı dosya
bu dosyalar derleme sonucu oluşan ve son kullanıcıya ulaşan dosya uzantılarıdır.


Microsoft Visual Studio ;

microsoft tarafından geliştirilmiş ve .net mimarilerinin tamamını kodlayabileceğimiz bir platformdur.

en çok kullanılanlar ;

debug       : kontrollü çalıştırma,
nuGet       : peket yükleme,
ErrorList   : Hata Listeleme

proje oluşturma nasıl yapılır.

proje      : içerisinde amaca uygun çözüm geliştirilen operasyonların yürütüldüğü bir bölümdür.
solution   : içerisinde bir veye birden fazla proje barındırabilen evrensel bir kümedir.


gerçek hayatta bir uyglama yazarken bu uygulama bir proje değil bir solution dur. 
bu solution birden fazla projenin birleşimi olabilir.


Visual Studio Code ile proje oluşturma ve derleme;

- create new project ile proje başlatılır.
- en basit uygulama console uygulamasıdır.
- solution name ile project name aynı olmak zorunda değildir.
- bir solution a birden falz proje eklemek istersek solution üzerine sağ tık yaparak Add/New project diyebiliriz.
- Derleme işleminden sonra oluşan bin klasörü altında yer alır.
- derleme sonucu : .deps.json, .dll, .pdb, .runtimeconfig.json uzantılı dosyalar oluşur.
- .net 6.0 ve .net 7.0 da da aynı dosya uzantıları mevcuttur.



Visual Studio Code , Visual Studio ya nazaran daha hızlı kod yazmaya yarar.

VS Code avantajları , 

- kendinde dahili bir komut satırı barındırır.
- komut satırında CLI adını verdiğimiz herhangi bir arayüzü olmayan bir asistan mevcuttur.

en yaygın kullanılan CLI komutlar:

ls : mevcut dizindeki dosya ve dizinleri listeler,
cd : dizinleri değiştirmemize yarar. 
pwd : şuanki dizinin yolunu gösterir.
mkdir : yeni bir dizin oluşturur.
touch : yeni bir dosya oluşturur veya oluşturulan dosyanın tarihinü günceller.

cp : dosyaları koplayalar,
mv : dosyaları taşır veya yeniden isimlendirir.
rm : dosyaları veya dizinleri siler 
cat: dosyaları birleştirir ve içeriklerini görüntüler
more veya less: uzun metin dosyalarını sayfa sayfa görüntüler.

- dizin ve dosya işlemleri :
grep : belirli bir metini dosya içerisinde arar.
find : dizinler arasında dosya arar.
chmod : dosya ve dizinlerin izinlerini değiştirir.
chowm : dosya ve dizinlerin sahiplerini değiştirir.

- ağ işlemleri : 
ping : bir IP adresini veya alan adını belirtilen sayıda paket gönderir ve yanıtları görüntüler,
ifconfig ve ip : ağ arayüzünü ve IP bilgilerini görüntüler,
ssh : uzak sunuculara güvenli bir şekilde başlanmamızı sağlar,

- paket yönetimi : 
apt-get : debian tabanlı işlemler için paketleri yinetir,
yum : red hat tabanlı işlemler için paketleri yinetir,
brew : macos tabanlı işlemler için paketleri yinetir,

-sistem bilgileri :
top veya htop : sistem kaynaklarını ve çalışan işlemleri görüntüler.
df : disk kullanımını gösterir.
free : bellek kullanımını gösterir.
uname : sistem bilgilerini gösterir.

- kullanıcı ve izinler ;
who veya w:aktif kullanıcıları ve oturum bilgilerini görüntüler,
useradd : kullanıcı ekler,
userdel : kullanıcı siler,
passwd : kullanıcı parolasını değiştirir.
sudo : yönetici veya süper kullanıcı haklarıyla komut çalıştırır.

- metin işlemleri :
echo : metin çıktısı üretir.
grep : metin içerisindeki desen eşleştirmeleri yapar.
sed : metin düzenlemesi yapar.


dotnet CLI ile proje oluşturma:

dotnet CLI ile proje oluştururken içerisinde bulunduğumuz komuta dikkat etmemiz gerekir.
dotnet CLI yı çağırmak için terminal ekranına 'dotnet' yazmamız yeterlidir.
dotnet --help ile dotnet üzerinden yapabileceklerimizi listeleyebiliriz.

uygulama başlatmak için ;

dotnet new (buraya uygulama tipini yazıyoruz) --name (buraya uygulama ismini yazıyoruz)

başlattığımız uygulamayı derleyebilmek için ;

dotnet build.


// dotnet CLI nedir?

Visual Studio idesinde kendi yaptığımız işlemleri komut satırı ile yapabilmek için CLI isimli asistandan aracılı ile yapabiliriz.


// dotnet CLI komutları nelerdir?

    1- help : dotnet CLI tarafından desteklenen komutlar hakkında ayrıntılı bilgi veren kokmuttur. ( dotnet help)

    2- new  : dotnet CLI üzerinden proje oluşturmaya yardımcı olan komuttur. (dotnet new (proje tipi) --name (proje ismi))

    not : sadece dotnet new yazıp enter tuşuna bastığımızda hangi proje tiplerini oluşturabileceğimiz konusunda CLI bize yardımcı olur.

    not: aynı isimde farklı bir dosya olmasından kaynaklı olarak oluşacak hatalarda (dotnet new (proje tipi) --name (proje ismi)) --force
    şeklinde satırın sonuna force keyword unu kullanırsak hata almadan işlemi yapabiliriz.

    3- restore : proje sürecinde referans edilen yahut referansı kaldırılan paketlerin restorasyonunu sağlar. (dotnet restore)

    referans mantığı nedir ? 

    bir yazılım geliştirme sürecinde işlemleri / iş mantıklarını genellikle kah kendimiz tarafından kah başkaları tarafından (ki genelde başkaları tarfından)
    önceden yazılmış kütüphanelerin desteğini alarak çözmeye referans mantığı denir.

    restore edilen paketler nuGet ten gelir.

    4- build : projeyi ilk önce restore eder ve sonrasında derler. sonuç olarak .exe ve .dll çıktıları verir. 
    bu .dll ve .exe uzantılı dosyalar /bin/Debug/net7.0 dizininde görüntülenir.

    not : proje derlemeden önce muhakkak restore edilir.


    5- publish : projeyi derleyerek yayınlanabilir dosyaların oluşmasını sağlar. çıktılar /bin/Debug/net7.0/publish dizininde bulunur.

    publish klasörü altında : 

    .dll,
    .deps.json,
    .runtimeconfig.json,
    .uygulama bağlantılarının .dll dosyaları

    bulunur.

    not : uygulamaya ait algoritmaları yayınlamak istemiyor olabiliriz, böyle bir durumda publish komutu bize yardımcı olur.
    not2: publish dosyalarında herhangi bir güncelleme yapılamaz, yapılan değişikliklerden sonra tekrar oluşturmak gerekir. çıktı almak gibi...

    6- run : uygulamayı derler ve ayağa kaldırır. (dotnet run ) 

    not : dotnet run --no-build uyulamayı derlemeden ayağa kaldırır.


// proje modifikasyon komutları:

    proje seviyesinde işlem yapmamızı ve referans ekleyip çıkarmamızı sağlayan komutlardır.

    paket / kütüphane : nuGet havuzundan gelir,
    referans          : önceden yazılmış .dll uzantılı dosyalardır.
    .exe uzantısı     : yazdığımız uygulamayı bir insan kullanacaksa bu uzantıda olur.
    .dll uzantısı     : yazdığımız uygulamayı bir yazılım kullanacaksa bu uzantıda olur.

    1- add package : uygulamaya nuGet'den paket / kütüphane yüklememizi sağlar.

    dotnet add package (paket ismi)  / ile terminalden paket yükleyebiliriz.

    2- add referance : uygulamaya fiziksel bir .dll uzantılı dosya referans etmemizi sağlar.

    diyelimki solution unumuzda birden fazla uygulama var ve bu uygulamalar birbirlerini referans etmek zorundalar.
    örneğin veri tabanı işlemlerini bir uygulama aracılığı ile yapıyoruz , iş mantığını / ana olayların cereyan ettiği olayları 
    başka bir uygulama ile yapıyoruz. ana olayların cerayan ettiği uygulamaya veri tabanı işlemlerinin yapıldığı uygulamayı
    referans etmek zorundayız.

    dotnet add referance (referasn edilen ana dosya).csproj referance (referans eden ufak dosya).csproj

    3- remove package : uygulamada add package ile yüklediğimiz paketleri/kütüphaneleri silmeye yarar.

    dotnet remove package ( package ismi)

    4- remove referance : uygulamaya referans edilmiş dll dosyalarını kaldırmaya yarar.

    dotnet remove referance (referans ismi)

    list referance : uygulamda referans edilen tüm paketleri / kütüphaneleri listeler.

    dotnet list referance 

    n adet uygulamanın olduğu bir solutionda çalıştığımızı varsayalım . 
    hangi uygulamanın hangi paketlerin/kütüphanelerin referans edildiğini kodlara bakmadan 
    bu yöntemle öğrenebiliriz

// programlamaya başlarken temel ilkeler:

    yeni çıkan her dil bir gelenek ve bir kabul ile yola çıkar. bunlara ilke diyoruz.

    ilke-1 : don't repeat your self 

    bir kod inşa edilirken kullandığımız dile ait bütün özellikleri bildiğimizi varsayalım ,
    aynı kod parçasını birden fazla yerde aynı yöntemle kullanırsak bu 1.ilkeye aykırı bir davranış olur. 
    günün birinde uygulamada tekrar eden kod parçalarında değişiklik yapmak istersek tek tek bütün kopyalarını bulmamız gerekir.
    bir algoritmayı öğrenerek birden fazla problemde aynı algoritmayı kullanmak 1.ilkeye uymaz.

    tecrübeden faydalanmak yaratıcılığı öldürür.

    ilke-2 : anlamlı isimlendirme,

    isimlendirme yaptığımızda anlamlı ve çağırışım yapan isim vermemiz gerekir.

// main fonkiyonu nedir ? 

    bir uygulama içerisinde muhakkak olması gereken bir fonksiyondur.
    program.cs dosyası uygulamanın başlangıç dosyasıdır ve başlangıç kodları burada bulunur.

    not : .cs uzantılı dosyalar c# dilinde yazılmış dosyalarıdır.

    başlangıç kodlarından kastımız nedir ?

    uygulama ayağa kalktığında işletim sistemi ile iletişim kurabilecek fonksiyonun 
    ve bu fonksiyon içerisinde başlangıca dair komutları barındıracak bir yapıdır.

    not : işletim sistemi ile sadece program.cs dosyası içerisindeki main fonksiyonu iletişim kurabilir.

    main fonksiyonu kuralları : 

    1- main fonksiyonu uyglamaya özgüdür ve her projede yanlızca 1 adet olur.
    2- aynı uygulama içerisinde 2.bi main fonksiyonu yoktur.


    işletim sisteminden parametre ile console'a değer yazdırabiliriz.

    static void Main(string[] args)
    {
        Console.WriteLine("Hello World!");
        Console.WriteLine(args[0]);
        Console.WriteLine(args[1])
    }

    terminalden dotnet run sedat mengü yazdığımızda çıktı ekranına ;

    Hello World!
    sedat
    mengü

// top level statement nedir ? 

    C# 9.0 ile gelmiştir.

// yorum satırları ve region özelliği : 

// tek satırlık yorumlarda kullanılır.

/*
çok
satırlık
yorumlarda
kullanılır
*/

region : kod dosyasını kategorik hale getirebilemizi sağlayan bir ön işlemci komutudur. 

developerların yazdıkları kodların daha net görebilmelerine yardımcı olur.

#region A operasyonu
    Console.WriteLine("Hello, World!");
    Console.WriteLine(typeof(char).IsPrimitive);
    Console.WriteLine(typeof(sbyte).IsPrimitive);
    Console.WriteLine(typeof(byte).IsPrimitive);
    Console.WriteLine(typeof(short).IsPrimitive);
    Console.WriteLine(typeof(ushort).IsPrimitive);
    Console.WriteLine(typeof(int).IsPrimitive);
    Console.WriteLine(typeof(uint).IsPrimitive);
    Console.WriteLine(typeof(long).IsPrimitive);
    Console.WriteLine(typeof(ulong).IsPrimitive);
    Console.WriteLine(typeof(float).IsPrimitive);
    Console.WriteLine(typeof(double).IsPrimitive);
    Console.WriteLine(typeof(decimal).IsPrimitive);
#endregion

#region A operasyonu

// todo özelliği : (editorun sağlamış olduğu bir özelliktir.)
kodun içerisinde yazılan notlara bir liste aracılığı ile ulaşmaya yarar. 

todo listesi genelde takım çalışmalarında hangi takım çalışanının müdahale etmesi istenirse o kişiye atıfra bulunulmak için kullanışlıdır.

todo listelerine erişmek için;

vs de görünüm/görevler penceresinden ulaşabilirz.
vscode da ise sol taraftaki çubukta 'source control' alanı içerisinden ulaşabiliriz.



// debuging :

    projenin her aşamasında en çok kullandığımız özelliklerdendir. platform ve teknoloji farketmeksizin her noktada kullanılır.

    brekapoint kavramı ;

    debug işleminde hassas olan satıra koyduğumuz ve debuging esnasında durduğumuz noktadır. 
    debug modda 1 adım ilerlemek için F10 tuşuna basaır. her basışımız uygulamanın bir adım daha ilerlemesini sağlar.

    F5 ile debug modu salmış oluruz ve uygulama sona kadar gitmiş olur.

    watch penceresi nedi ? 

    debug modda çalıştırma esnasında bazı değişikliklerin değerlerini izlemek isteyebiliriz. 
    debug çalışırken izlemek istediğimiz değişkenin üzerine tıklayarak 'izleme ekle' seçeneğini seçerek 
    watch penresesine eklemiş oluruz.

    peki debuguz uygulamayı çalıştırmak nasıl olur?

    debug zaman ve performasn açısından maliyetli bir yoldur. genelde projemizden emin olduğumuz durumlarda debugsuz çalıştırabiliriz.

// değişkenler nelerdir ?

değişkene neden ihtiyaç duyarız.

amaç : elimizdeki verileri doğru yazılımlar ile doğru bir şekilde işleyerek doğru sonuçları elde etmektir.

yazılım herhangi bir veri tutmaz , işlem gerçekleştiği esnada veriler RAM'da tutulurlar , oradan alınır, kullanılır , ve geri yerine konur...

işte bu noktada değişkenleri RAM'de tutabilmek için değişkenleri kullanılırız. 

veri tabanındaki verileri direkt olarak işleyemeyiz, değişken yardımı ile RAM'den alıp değiştirip geri yerine koyarız.

önemli not: iş yapıyorsak RAM'de çalışmalıyız.

tanım : yazılımda işlenecek veriyi yazılım adına RAM'e yerleştirebilmek için biz developerlar değişkenleri kullanırız.

value type ve primitive type nedir ?

C# dili yapısı gereği RAM'e yerleştireceğimiz veri türünü bilmek ister ki ona göre bir alan tahsisinde bulunsun.

. bir değişkenle RAM'de alan tahsisinde bulunulduğunda buna 'değer türlü değişken' ( value type) deriz. yaş,boy,isim,trih vs...
. birden fazla farklı tipte değişken barındırabilen yapılara 'referans türlü değişken' deriz.

ad : "ali"; -- değer türlü değişken
soyad:"uzun"; --değer türlü değişken
yas=23; --değer türlü değişken
kanGrubu='a' -- değer türlü değişken

yukarıdaki bilgilerin tamamı paket olarak da referans türlü değişken olarak tanımlanır.

tanım : sadece bir tür değer tutan değişkenlere değer türlü değişken denirken, birden faza değişik türde değişken tutabilen türlere referans türlü değişken denir.

primitive type : ham veri , türetilmemiş veri anlamında kullanılır ve en ilkel türdür. (byte)

not : RAM'de değişken için alan tahsis edileceği zaman değişkenin türündne hareket edilir ve hangi türde değişken tanımlandıysa o türde değişken barındırılır.
string ile tahsis edilen alana double türünde bir veri barındıramazsınız , veya char türünde bir alan tahsisinde bulunduysanız int türünde bir değer barındıramazsınız. barındırtmazlar :)

veri türleri :

    bool : true veya false tutabilir.   (1 bit )

    char : tek karakter tutabilir.   (16 bit )

    sbyte : -128 ile +127 arasındaki değerler tutabilir.   (8 bit )

    byte : 0 ile +255 arasındaki değerler tutabilir.   (8 bit )

    short : -32768 ile +32767 arasındaki değerler tutabilir.   (16 bit )

    ushort : 0 ile 65535 arasındaki değerler tutabilir.   (16 bit )

    int : -2147483648 ile +2147483647 arasındaki değerler tutabilir.   (32 bit )

    uint : 0 ile +4294697295 arasındaki değerler tutabilir.   (322 bit )

    long : -9233372036854775808 ile +9233372036854775807 arasındaki değerler tutabilir.   (64 bit )

    ulong : 0 ile +18446744073709551615 arasındaki değerler tutabilir.   (64 bit )

    float : +- 1.5 x 10(-45) ile +-3.4x10(38) arasındaki değerler tutabilir.   (32 bit )

    double : +- 5x10(-324) ile +-1.7x10(308) arasındaki değerler tutabilir.   (64 bit )

    decimal : +-1.5x10(-28) ile +-7.9x10(28) arasındaki değerler tutabilir.   (128 bit )

    string : metinsel ifadeleri tuttuğumuz değişken türüdür ve referans tiplidir.

    yukardaki türlerden sadece 'decimal' primitive değildir , geri kalan türlerin tamamı primitive dir.

    bir türün primitve olup olmadığını nasıl kontrol edebiliriz.


    Console.WriteLine(typeof(bool).IsPrimitive);
    Console.WriteLine(typeof(char).IsPrimitive);
    Console.WriteLine(typeof(sbyte).IsPrimitive);
    Console.WriteLine(typeof(byte).IsPrimitive);
    Console.WriteLine(typeof(short).IsPrimitive);
    Console.WriteLine(typeof(ushort).IsPrimitive);
    Console.WriteLine(typeof(int).IsPrimitive);
    Console.WriteLine(typeof(uint).IsPrimitive);
    Console.WriteLine(typeof(long).IsPrimitive);
    Console.WriteLine(typeof(ulong).IsPrimitive);
    Console.WriteLine(typeof(float).IsPrimitive);
    Console.WriteLine(typeof(double).IsPrimitive);
    Console.WriteLine(typeof(decimal).IsPrimitive);

    örnek : 1000 değerini short , ushort , int , uint , long , ulong , float , double , decimal türlerinin tamamı ile tutabiliriz.
    ancak yer proje optimizasyonu için en makul aralık olan short veya ushort u kullanmamız gerekir.

// C# dilinin temel kuralları : 

1- bütün kodlar main fonksiyonu içerisine yazılır.
2- { } bu yapı scope olarak değerlendiril (faliyet alanı)
3- C# BÜYÜK ve küçük harf duyarlılığna sahiptir. "ahmet","Ahmet","AhMet","AHMET" tamamen ayrı şeklerdir.
4- C# dili tip güvenliği olan bir dildir. 

değişken tanımlama;

degisken_turu degisken_adi;

bu şekilde ilk yazılacak olan değişkenin türüdür 2 yazılacak olan değişkenin anlamlı ismidir. (anlamlı olması 2.ilke)

örnek:

string adi;  --> bu şekilde RAM'de "adi" isminde string bir alan rezervasyonu yapılmış oldu. 
int yas ; --> bu şekilde RAM'de "yas" isminde integer bir alan rezervasyonu yapılmış oldu. 

ram yapısı : 

stack ve heap ram da kullandıığımız 2 alanın adıdır.

stack : içerisinde değer türlü değişkenlerin;

değişken türünün , 
değişken adının,
değişken değerininin,
metot/fonksiyon isimlerinin,

tutulduğu bir bölümdür.

heap : nesnelerin tutulduğu bölümdür.

not : stack içerisinde tutulan değişken ismine nadiren de olsa 'referans' dendiğini görebilirsiniz.
not : stack alanıda değişkene herhangi bir değer ataması yapılamasa dahi yer tahsisi yapılır.
not : metotların/fonksiyonların bellek adresleri de stack de tutulur.

metotları / fonksiyonları çağırmak üzere oluşturuyoruz ve bu metotlar/fonksiyonlar isim üzerinden çağırırız ve bu isimde denk gelen adres stack alanında tutulur.


değişken tanımlana kuralları:

değişken isimleri ilerleyen süreçte developer açısından karışıklığa mahal vermemek için anlanlı olmalıdır.
değişken isimleri . ' , gibi özel karakterler barındırmamalıdır. _ istisnadır.

1sayi olmaz , sayi1 olabilir.
ad? olmaz , ad olabilir,
stok.adedi olmaz , stok_adedi olabilir.

not : aynı scope içerisinde aynı isimde birden fazla değer tanımlanamaz.

isimlendimre gelenekleri ;

1- snace_case ; tük hrafler küçüktür ve kelimelerin arasına _ konur.

. kullanici_adi;
. isim_soyisim;
. personel_giderleri;

2- Pascal Name : her kelimenin ilk harfi büyük yazılır. klaltmalar özellikler büyük harf ile yazılır.

. AdSoyad;
. TcKimlikNo;
. Satislar;
. DogumTarihi;
. InOut = IO,
. InOutStream = IOStream;

3- camelCase : sadece ile kelimenin ilk harfi küçük yazılır, takip eden kelimelerin ilk harfleri her zaman büyük yazılır.

. satisDurumu;
. personeAdi;
. orderId;
. userNAme;
. userNAmePassword;

değişken isimlerinde @ operatörü : 

string x şeklinde bir değişken tanımlayabildiğimiz gibi string @x şeklinde de tanımlama yapabiliriz. 
ancak ahm@t gibi @ karakteri ismin ortasına kullanılırsa özel karaktere girer ve kabul edilmez.

static , for , if , string , int gibi programa özgü kelimeleri @ ilavesi ile değişken ismi olarak kullanabilirz.

string @string ,
int @int , 
double @double , 
string @static vb.

tanılanmış değişkene değer atama : 

int x ; şekilde herhangi bir değer ataması yapmadan da değişken tanımlayabildiğimiz gibi int x=5; gibi tanımlanmış değişkenlere de tekrardan değer atayabiliriz.

burada dikkat edilmesi gereken şey, bir değere en son atanan değer geçerlidir.

değişeken değer atama kuralları ;

değer türleri : 

1- metinsel değerler ; string keywordu ile tutulur, "..." içerisine yazılmalıdır. "gencay" , "12345678901" vb.

not : bir sayısal ifade "..." arasında metinsel bir biçimde tutuluyor ise herahngi bir matematiksel işleme kapalıdır.

2- karaktersel değerler: char keywordu ile tutulur , '...' içerisinde yazılırlar. 'a' , 'b' vb.

not : 'ab' şeklide birden fazla karakter barındırması durumunda program bu noktada hata verecektir.

3- mantıksal değerler : bool keywordu ile tutulur. true ya da false değerleri alabilir.

not : "True" ile true aynı şey değildir.

4- sayısal değerler : int,short,long,decimal .... gibi keyword ler ile tutulurlar. herhangi bir tırnak kullanmayız.

not : sayısal ifadeler varsayılan olarak int türündedirler.

5- ondalıklı değerler : float , double ve decimal keywordu ile tutulurlar. 

not : tüm ondalıklı sayılar tamsayıları karşılayabilirler.

a- float : bu türde bir değişkene değer ataması yapılırken değerin sonuna f veya F ifadesi eklenmelidir.

float @float = 3.14f , float @float2 = 3.15F vb.

b- double : bu türde bir değişkene değer ataması yapılırken değerin sonuna d veya D ifadesi eklenmelidir.

double @double = 3.16d veya double @double2 = 3.17D vb.

c- decimal : bu türde bir değişkene değer ataması yapılırken değerin sonuna m veya M ifadesi eklenmelidir.

decimal @decimal = 3.17m veya decimal @decimal2 = 3.19M vb.


not : ondalıklı türlerde bir değer default olarak double dır. (sonuna d veya D gelmesi gerekir.) default olduğundan dolayı değerin sonuna d ve D koymasak da olur.

not : char türünde bir değişken tanımlayacak isek "..." şeklinde çift tırnak kullanamayız.
not : string türünde bir değişken tanımlayacak isek '...' şeklinde tek tırnak kullanamayız.

tuple türünde veri atama : 

tuple : tek bir syntax üzerinde birden fazla değişken tanımayabilmemizi sağlayan bir nesnedir.

not : tuple değişken içerisinde int, string , double , vs olmak üzere birden fazla aynı veya farklı türde değişken tanımı mevcuttur.

(int a, string b) @tuple = (5,"kemal");

literal düzenleme : int x = 1000000; şeklinde gösterimi int x=1_000_000; şeklinde de gösterebiliriz.


// değişken türüne uygun default değer atama;

    tüm değişkenlerin bir default değeri vardır. 

    not : main fonksiyonu içerisinde tanımlanan bütün değişkenlerin default değerleri otomatik olarak atanmaz,
    class içerisinde tanımlanan fonksiyonların değerleri default olarak atanır.

    varsayılan değerler : 

    bool : false,
    sayısal : 0,
    char = '0',
    strign = null

    main içerisinde bu deperler otomatik olarka gelmez class içerisinde tanımlanan değerlerde otomarik olarak gelir.

    main scopu içerisinde default değeri atamak için,

    bool x = default;

    Console.WriteLine(x);

    console a False değeri yazılır.

// tanımlanmış bir değerin değerini okuma :

    int x = 5;  // (integer türünde x adında bir alan tahsis edildi ve içerisine 5 değeri atandı.)

    int y = 10;  // (integer türünde y adında bir alan tahsis edildi ve içerisine 10 değeri atandı )

    int z = x ;  // (integer türünde z adında bir alan tahsis edildi ve içerisine x (yani 5 değeri) atandı)

    z = y ;  // (daha önce z adını alan ve türü belirtilen bir alan tahsis edildiğinden herhangi bir hata oluşturmadan z değişkenine y ( yani 10 değeri) atanır.)

    b = x ;  // (daha önce b adında bir değişken adı ve türü belirtilmediği için bu kod satırı hata verecektir.)

    RAM'da alan tahsis edilirken 2 kritik vardır. bunlardan bir tanesi eksik olursa değişken tanımlanamaz.

    1- veri tipi ( int , string, bool, char vb.)
    2- değişken ismi ( isim , numarala, sira , sayi vb.)

    önemsiz not : int a = 5; a = a ; dediğimizde herhangi bir hataya sebebiyet vermez. bir değişkene aynı türde aynı değeri saklaması için verebiliriz.

// değeri olmayan değişkenler. 

    main içerisinde atanmış bir karşılığı olmayan değer ile ( int x ;) hiç bir şey yapamayız. 
    çünkü burada uygulamaya int türünde ve x isminde bir alan tahsis edeceğiz dedik ve main yapısı gereği default değer atamaz.
    ancak bu (int x;) ataşmış karşılığı olmayan bir değişkeni class içerisinde kullanabiliriz. default değerler otomatik atanır.

// değişken davranışlarına genel bakış , 

    bir değişkenin kendini göndermek ile değerini göndermek arasında fark vardır. 
    değerini göndermek şu şekilde olur.

    int x = 9;  // (burada stack alanında int türünde x adında içerisinde 5 değerinin tutulduğu bir alan tahsisi yaptık.)
    int y = x;  // (burada stack alanında int türünde y adına içerisnde x in değerinin tutulduğu bir alan tahsisi yaptık.) x in kendisini atmadık , değerini tanımladık.
    y = 20;  // (burada stack te barındırılan y değişkenine 20 değerini atadık. x değişkenine herhangi bir şey olmadı.)

    Console.WriteLine(y);  // 20 

// değişkenlerin faliyet alanları : 

    scope : değişken ve fonksiyonların sınırlarını belirler. tanımlamalarda ve algoritmik çalışmalarda karışıklığı önler.

    { } --> scope 


    not : bir scope içerisinde tanımlanan değişkene o scope içerisinde tanımladığı satırdan sonra herhangi bir yerden erişebiliriz.
    iç içe tanımlanan scope larda en dışta tanımlanan scope daki değişkene en içteki scope dan erişebiliriz ancak tersi mümkün değildir.


    scope lar nerelerde kullanılır;

    1- namespace , classlarda , metotlarda , döngülerde , if yapısında scope kullanılır.
    2- herhangi bir keyword e bağlı kalmadan da scope oluşturabiliriz.

// değişmezler.

    sabitlere neden ihtiyaç duyarız?

    - bazen sabit değerler ile de çalışmamız gerekebilir. 
    sabitlerin asıl amacı bir başka yazılımcı tarafından değiştirilmesini istemediğimiz durumlarda kullanırız. bir diğer avantajı ise
    kendi hatalarımızın önüne geçmektir. dalgınlıkl değiştirmememiz gereken bir noktada deişmemesi gereken bir değeri değiştirebiliriz.

    development aşamasında 'sabit' olarak tanımlanmayan bir değer değiştirilirse hehrangi bir hata ile karşılaşmadan compiler işlemi tamamlanır.
    en erken uygulama çıktılarını görüntüleme aşamasında mantıksal hatalar olduğunu anlayabiliriz. bu noktadan sonra hatanın yerini tespit etmemiz birhayli uzun sürecektir.

    sabitleri nasıl tanımlayabiliriz ? 

    - const keywordu ile tanımlarız.

    prototip olarak değişkenlere çok benzer ancak davranışsal olarak değeri bir daha değiştirilemez. değiştirme aşamasında hata mesajı alırız.
    özünde staticdir.

    static nedir ? 

    - static uygulama bazlı veri depolayabildiğimiz bellekte bir alandır.

    - scope içerisinde tanımlanan bir değişken gene sadece aynı scope içerisinden erişime izin verir, static'e konulan bir değer / değişken evrenseldir ve uygulamanın herhangi bir yerinden erişime açıktır.

    static ile const arasındaki fark nedir ? 

    - static değişkendirler , const'lar değişmezdirler.

    readonly : sadece okunabilir değişkenler tanımlanmaktadır.

    const tanımlandığı anda değer ataması yapılmak zorundadır. alan tahsis edeyim, ileride bu alanı dolduracağım olmaz.

    readonly de ise const'a ilave olarak constructure da da değer ataması yapabiliriz. 3.bi değer ataması yapamayız, bir defa değer ataması yapınca değiştiremeyiz.

    readonly static değildir.

    const değişken tanımlama : 

    int a = 5 ;         // (bu şekilde int türünde a adında içerisinde 5 rakamının tutulduğu alan tahsis ettik ama kapı her zaman açık)

    a = 8;              // (bu şekilde a değişkenine giderek değiştirebiliriz.)

    const int b = 7;    // (bu şekilde int türünde b adında içerisinde 7 değerinin tutulduğu alan tahsis ettik ve const ile kapıyı kilitledik.)

    b = 11;             // (const ile kapıyı kiltlediğimizden dolayı b değeri üzerinde değişiklik yapamayız.)

// global ve local değişkenler , 

    bir değişken konumlandığı yere göre locak veya global diye isimlendirilirler. 
    yapı ve işleyişte herhangi bir değişiklik olmaz sadece isimlendirme yapılmıştır.

    class scope u içerisinde tanımlanan değişkenlere global değişken denir.
    metotlar içerisinde tanımlanan değişkenlere local değişlen denir.

// değişken tanımlama varyasyonları: 

    1- int a; veya int a = 5;   // klasik varyasyon

    2- aynı türde birden fazla değişken oluşturulması gereken durumlarda kullanılabilir.
    int x = 3, y= 4, z=5; --> alan tahsis ettik ve değer atamsı yaptık.
    int x,y,z;  --> alan tahsis ettik ve değer ataması yapmadık.

// değişkenler arası değer atama.

    1- deep copy : eldeki veri klonlanır. 1 iken 2 veri oluşur.

    not : değer türlü değişkenler birbirine atanırken default olarak deep copy geçerlidir. yani veri otomatik olarak türetilir.

    int a = 7;  ---> (stack alanında int türünde a isminde 7 değişkenini tahsis ettik.)
    int b = a;  ---> (stack alanında int türünde b isminde a değişken (değerini deep copy olarak) tanınladık. )
    b = b * 3;  ---> (deep copy olarak kopyaladığımız a değişken değeri değişmeden b üzerinde matematiksel işlem yapabiliriz.)

    Console.WriteLine(a);  // 7
    Console.WriteLine(b);  // 21 

    b değişkeni a değişkeninden deep copy copyalandı ve sonrasında a değişkeni bu kopyalamadan etkilenmeyecektir.

    2- shallow copy :  birden fazla referansla işaretlemeye dayalı kopyalama yöntemidir.

    bellekte birden fazla referansın tek bir veriyi işaret etmesidir.

    neticede ilgili değer bir değişikliğie uğradığında tüm işaretleyen referanslara da bu değişiklik yansıtılacaktır. (Autocaddeki blok editor mantığı)

    A ve B değişkenleri heap daki aynı değeri kullanıyorlar, heap daki değer değişirse A ve B bu durumdan etkilenecek.

    not : değer türlü değişkenlerde bilinçli olarak shallow copy yaptırılabilir. 

    not2 : nesne ve referans arasındaki ilişkide varsayılan davranış olarak kabul edilmektedir.

// object türü : 

    tüm türleti karşılayabilen , referans türlü ve stack de tutulmayan bir türdür.
    object olarak tanımlanan değişkenler şeffaf bir kutu gibi içerisinde tutulmuş gibidir. object içerisinde herhangi bir türde , tür değişmeden tutulur. (boxing özelliği)


    boxing özelliği : 

    object bir değişkene herhangi bir türdeki değer türünde bir değişikliğe uğramadan göndermektir. boxing işlemi neticesinde ilgili değer object in içerisinde kendi türünde saklanır.

    object türünde tutulan hangi tür veri olursa olsun o türde bir işleme tabi tutulamaz. int ise matematiksel olarak işlem yapılamaz, string ise metinsel işlemler yapılamaz.

    boxing işlemini şeffaf bir kutu olarak düşünebiliriz. içerisi görünüyor ancak işlem yapmaya kapalı.

    şeffaf kutulama olarak adlandırdığımız boxing de tutulan değişkeni işlem yapılabilir hale getirmek için unboxing işlemi yapmak gerekir.

// cast operatörü : 

    boxing edilmiş bir veriyi kendi türünde işleme açabilmemize yardımcı olan bir opeartördür.

    not : bilinçli tür dönüşümünde de cast operatörü kullanılır. 
    not2: kalıtımsal durumlarda da cast operatörü kullanılır.

    () ---> cast operatörü . object değeri alır.

    cast kullanımı : 

    object A = "cem";                   ----> veri türü : object , değişken ismi : A 

    string isim = (string)A ;           ----> veri türü : string , değişken ismi : isim (cast ı burada kullandık) (cast olarak türüne uygun olarak değeri istemek gerekir.)

    Console.WriteLine(isim.ToUpper());  ----> veri türü : string , değişken ismi : isim 

    cast object boxing unboxing iç içe ifadelerdir. buna bi örnek verelim.

    object _yas = 32; ---> veri türü : object , değişken ismi : _yas olan bir alan tahsis ettik. 

    Console.WriteLine(_yas*3);  ---> sonuç ekrana bastırılamaz.

    int yas = (int)_yas ; ---> _yas isimli değişkenini cast operatörünü kullanarak unboxing yaparak int değişkeni içerisine koyduk.

    object neden kullanılır? 

    - dışarıdan alınan verilerin türleri bilinemediği durumlarda kullanılır.

    not : int olarak boxing edilen bir veriyi string veya char türünde unboxing edersek runtime esnasında (tam son noktada) hata verir. bigbang

// var keywordu nedir ? ne işe yarar? 
    
    Tutulacak değerin türüne uygun bir değişken tanımlamak bizim elimizdedir. ancak bazen bunu biz compilera yaptırmak isteriz. bunu var keywordu ile tanımlarız.

    bool medeniHal = true;     // var medeniHal = true;
    string isim = "nazmi";     // var isim = "nazmi";

    bunları biz tanımladık          bunları compiler yaptı.


    'var' keywordu atanan değerin türüne bürünür.

    var ne zaman kullanılır ? 

    diller arası entegrasyonda kullanılır. X dilinde tanımlanan t adında bir değişken vardır diyelim , biz bu t adındaki değişkenin C# dilindeki karşılığını bilemeyebiliriz.
    bu noktada 'var' yazıp geçeriz.

    not1: 'var' keywordu ile tanımlanan değişkenin değeri tanımlama aşamasında verilmelidir.
    not2: 'var' keywordu ile tanımlanan değişkene ilk değer verildikten sonra o türe bürüneceğinden dolayı aynı tür üzerinden ilerlemek gerekir.
    not3: 'var' ile object arasındaki fark , var işleme açıktır , object unboxing etmeden işleme kapalıdır.

// dynamic keywordu : 

    dynamic b = 5; ---> development sürecinde b her daim dynamic türde görünecektir. uygulama derlenip çalıştırıldığında dynamic ilgili değerin türüne bürünmüş olur.

    var x = 5;   ---> bu satırdan sonra x integer bir davranış sergiler ve integer e has işlemlere tabi tutulabilir.

    dynamic y = 10 ; ---> bu satırdan sonra runtime a kadar y dynamic davranışlar sergiler.


    dynamic özelliği nedir ? 

    - . ya bastıktan sonra otomatik olarak kullanılabilecek özellikler listelenir.

    Console.SetWindowSize
    Console.Write
    Console.WriteLine
    Console.SetWindowPosition

    buradan Console. dan sonra liste çıkar ve kullanılabilecek olan özellikler listelenmiş olur. burada Console dynamic olsaydı . ya bastıktan sonra hiç bir özellik görünmeyecekti.

    dynamic olan verilerde manuel olarak .Write , .WriteLine şeklinde yazmamız gerekir. buna karşılık bir hata olup olmayacağını dotnet run demeden bilemeyiz.

    not : dynamic keywordu runtime türü belirleyecektir ancak kararlı davranmayacaktır. bunu bi örnekle açıklayalım.

    dynamic x = "ali";
    Console.WriteLine(x.Gettype());
    x = true;
    Console.WriteLine(x.GetType());

    // string
    // boolean

    dynamic geçici veri tutma yeridir diyebiliriz.

    dynamic nerelerde tercih edilir?

    türünü bilmediğimiz ve verinin geldiğini düşünelim. var keywordu uzaktan gelen verilerde kullanılmaz.

    not : uzaktan gelen verilerin hangi türde olduğunu bilmediğimiz verileri karşılarken dynamic keywordu kullanılır. 
    uzaktan gelen veriyi var ile tanımlayamayız çünkü var tanımlandığı anda verinin atanmasını ister. dynamic runtime'a kadar bekleyebilir.

    int b = 5;
    b="kale";
    b = true;

    int veya başka bir belirli tür bu değişikliğe izin vermez.

    dynamic a = 3;
    a = true;
    a="isim";

    dynamic türde esneklik sağlar.

// değişkenler genel tekrar soruları:

    1- değişken nedir ve neden ihtiyaç duyarız.

    yazılımın amacı eldeki verileri bir şekilde anlamlı hale getirmektir. elimize bir şekilde geçen verileri , bu elimize geçme bir işlem neticesinde olabilir , 
    bir veri tabanından gelebilir , bir client tarafından gelebilir. developer ların amacı bu veriyi amacına uygun bir şekilde yönlendirerek arzu edilen sorulara
    cevap vermektir.

    2- value type , primitive type , nedir ? 

    value type      : yas , isim , tckimlik gibi değişkenleri tutan değerlerdir.
    primitive type  : diğer türler tarafından türetilmiş türlerdir.

    Console.WriteLine(typeof(bool).IsPrimitive);        // True
    Console.WriteLine(typeof(char).IsPrimitive);        // True
    Console.WriteLine(typeof(sbyte).IsPrimitive);       // True
    Console.WriteLine(typeof(byte).IsPrimitive);        // True
    Console.WriteLine(typeof(short).IsPrimitive);       // True
    Console.WriteLine(typeof(ushort).IsPrimitive);      // True
    Console.WriteLine(typeof(int).IsPrimitive);         // True
    Console.WriteLine(typeof(uint).IsPrimitive);        // True
    Console.WriteLine(typeof(long).IsPrimitive);        // True
    Console.WriteLine(typeof(ulong).IsPrimitive);       // True
    Console.WriteLine(typeof(float).IsPrimitive);       // True
    Console.WriteLine(typeof(double).IsPrimitive);      // True
    Console.WriteLine(typeof(decimal).IsPrimitive);     // False
    Console.WriteLine(typeof(object).IsPrimitive);      // False
    Console.WriteLine(typeof(string).IsPrimitive);      // False


    buradan çıkartılacak sonuç decimal , object ve string türleri primitive tür değillerdir.

    not : tanımlanmış bir dğeişkene değer atamak için önceden o değişkenin tanımlanmış olması zorunludur.

    örnek :

    int a ;

    a = 6;  // dada önce stack alanında 'a' isminde bir değişken ve alan oluşturduğumuz için içerisine türüne uygun bir değer ataması yapabiliriz,
    b = 9;  // daha önce stack alanına 'b' isminde bir değişken ve alan oluşturmadığımız için içerisine herhangi bir değer ataması yapamayız.


    tuple türü : içerisinde birden fazla değişken barındırabilen bir yapıdır.

/// kod nasıl çalışır ;

    kodun çalışması için geliştrilmiş 2 adet yöntem vardır.

    1- senkron çalışma  : bir işlem bitmeden diğer bir işlemin başlamadığı , yöntemdir. (trafikte öndeki araba gitmeden arkadaki araba gidemez).
                        bu yöntemde herhangi bir t anında yapılan işi tespit edebiliriz.

    2- asenkron çalışma : paralel olarak birden fazla işin aynı anda yapılması yöntemidir. (oyun oynarken müzik dinlemeyebiliriz).
                        bu yöntemde herhangi bir t zamanında yapılan işi tespit edemeyiz.

    not : yazılımlar varsayılan olarak senkron çalışırlar , ancak gelişen teknolojiler sayesine tamamına yakını asenkron olarak yola devam ederler.

/// kod konsepti nasıldır ? nasıl oluşturulur

    kod inşa edilirken her zaman şu yapı vardır.

    _____________ = _____________
    tür ,           bu taraftaki yazılı olan kodlar bir işlem
    referans,       yapacak ve geriye bir değer döndürecek.
    değişken vs.    (değer döndürmeyede bilir , böyle durumlarda bu kısım olmaz.)

    sağ tarafta bir işlem yapılacak ve sol taraftarki tür , referans , değişken vs ye atanacak.

/// ; operatörü

    ; operatörü compiler tarafından konseptin bittiğini işaret eder. compiler satır satır değil konsept konsept çalıştığından dolayı bu ; operatör üçok önemlidir.

    not : bir konsept biter ve konseptin sonuna ; işaretini koymaz isek hata alırız:
    nor : ; operatörü birden fazla kullanılabilir herhangi bir hataya sebebiyet vermez ancak hoş karşılanmaz. 
    not : compiler tarafından kodlar satır satır değil konsept konsept derlenir.

/// tür dönüşümü nedir ve neden ihtiyaç duyarız?

    development sürecinde elimizdeki verilerin türlerini değiştirebiliriz. ancak her tür istediğimiz bir türe dönüşemez. 
    örneğin elimizde bir 'elma' var ve biz bu elmayı en fazla bir üst sınıf olan 'meyve' türünde saklayabiliriz.
    bir development hiçbir şeyi boş yere yapmaz. kodlamanın temel mantığını biz elimze bir şekilde gelen veriyi uygun hale getirerek,
    uygun çıktılar oluşturmak için bu yola girdik , ve bu yolculukta elimze string bir değişken geldiğini varsayalım. 
    bu string ifadenin değeri "123" olsun. bu veriyi string olarak *2 işlemine tabi tutamıyoruz ancak çarpmamız gerekiyor.
    tam bu noktada tür dönüşümüne ihtiyacımız vardır.


    not : tür dönüşümleri mantıksız olmamalı.
    not : farklı servislerden gelen verileri uygun türlere dönüştürme ihtiyacı olabilir, bu noktada tür dönüşümü yapılmalıdır.
    not : elimzideki veriye uygun olmayan bir türe dönüştürmeye çalışmak hatalara sebebiyet verebilir. örneğin bool türündeki bir veriyi char içinde tutamayız.

    örnek  : elimizde 'meyve' verisi var. 'meyve' içerisinde elam olduğunu biliyoruz, bu türü 'armut' olarak dönüştürürsek patlarız.
    örnek2 : bir şekilde elimize 'ahmet' diye bir veri geldi. biz bu veriyi bool türüne dönüştüremeyiz.
    örnek3 : bir şekilde elimize "123" diye bir veri geldi . biz bu veriyi char türüne dönüştüremeyiz.

/// Parse fonksiyonu:

    metinsel ifadeleri diğer türlere dönüştürmeye yarayan fonksiyondur.
    herhangi bir string ifadeyi int , bool , char gibi türlere dönüştürür.

    not : sadece string ifadelerde dönüşüm yapabilir.


    string ------> Parse ------> char (olur)
    string ------> Parse ------> int (olur)
    string ------> Parse ------> bool (olur)
    int    ------> Parse ------> string (olmazzzzzz)

    kullanımı : 

    string x = "123";

    Console.WriteLine(int.Parse(x) * 2); -----> // 246 

    çözülmesi gereken soru:

    dışarıdan elimze string bir ifade geldi ve biz bu ifadenin 2 katını alacağız.

    çözüm :

    sonuca ulaşmak için 2 ile çarpabilmek için matematiksel bir ifadeizin olması gerekir. 
    bu sebepten dolayı elimizdeki veriyi matematiksel bir veriye dönüştürdük ve sonuca ulaştık.


    önemli not : tür dönüşümlerinde dikkat edilmesi gereken tek husus dönüşüm yapılacak verinin türüne uygun bir hedef belirlemektir.

    dynamic x1 = "12";

    Console.WriteLine(short.Parse(x1)*2); -----> // 24

    var a = "9";

    Console.WriteLine(double.Parse(a)*2); -----> // 18

    object a1 = "7";

    string b = (string)a;       ---> object türündeki veriyi burada unboxing yaparak string bir veriye dönüştürdük.

    Console.WriteLine(int.Parse(b)*3);  -----> // 21

    bu son örnekte object türünden bir veri üzerinde işlem yaptığımızdan kaynaklı olarak boxing-unboxing işlemine tabi tutma ihtiyacı oluştu.

/// convert fonksiyonu : 

    herhangi bir türü herhangi bir türe dönüştürmek için kullanılır. Parse komutunun yaptıklarını da yapabilir.

    not : int16 - short türüdür
        int32 - int türüdür
        int64 - long türüdür.


    parse fonksiyonu ile dönüşüm : 

    string x = "123";

    Console.WriteLine(int.Parse(x) * 2); -----> // 246 

    convert fonksiyonu ile dönüşüm:

    string x = "123";

    Console.WriteLine(Convert.ToDouble(x) * 2); -----> // 246 

    int a = 100 ;

    Console.WriteLine(Convert.ToString(a)+2);         -----> // 1002
    Console.WriteLine(typeof(a));                     -----> tür dönüşümü yapılan bir değişkenin typeof ile türünü bulamadık.

/// metinsel olmayan ifadeleri metinsel ifadeye dönüştürmeye alternatif 

    metinsel olayan ifadeleri convret fonksiyonu yardımı ile yapıyorduk ancak burada bir yöntem daha var. tostring fonksiyonu.

    int a = 100 ;

    Console.WriteLine(a.ToString()+100); -----> //100100  

    (herhangi bir türdeki verileri string ifadeye çevirmek istersek Convert kullanmadan da bu şekilde yapabiliriz.)

    bu özellik sadece string e çevirmek için kullanılır. 
    
/// sayılar verilerde kendi aralarında tür dönüşümleri .

    2 şekilde bu tür dönüşümü mümkünüdür.

    1- en dar aralıktaki türden en geniş aralıktaki türe dönüş. 

    (en dardan en genişe türler)

    byte < short < int < long < float < double < decimal

    örnek vermek gerekirse byte türünde bir değişkeni herhangi programa herhangi bir açıklama yapmadan short veya daha üst bir sınıfa dönüştürebiliriz.

    byte a = 10;
    short b = a;        // burada herhangi bir hata ile karşılaşmayacağız ve program bu dönüşümü otomatik olarak yapacaktır.


    2- en geniş aralıktaki türden en dar aralıktaki türe dönüş,

    byte < short < int < long < float < double < decimal

    örnek vermek gerekirse long türünde tanımlanmış herhangi bir değeri herhangi bir açıklama yapmadan (değer aralığı içerisinde ols dahi) int , short , byte türlerine dönüşüm yapamayız.

    long a = 100;
    int b = a;      // burada hata ile karşılaşırız. sebebi herhangi bir açıklama yapmadan türü daraltıyor olmamızdır.

    long a = 100;
    int b = (int)a ;    // bu şekilde cast operatörleri içerisine a dönüşüm yapmak istediğimiz türü yazarsak hata ile karşılaşmayız. bir nevi programa açıklama yapmış oluyoruz.

    bu örnekte long bir alt tür olan int e dönüştü ancak short veya byte türüne de dönüşebilirdi. 

    not : eğer değer aralığı dışında kalan bir rakam olursa modunu alarak kalan sayıyı ekrana yazdırır.

?? tür dönüşümlerine neden ihtiyaç duyarız ??

    farklı türlerdeki verileri birbirleri ile işleme alabilmek için , örneğin bir tam sayı ve bir metin değerini toplamak gerekse bunu yapabilmek için her 2 değerin de 
    aynı türde olması gerekir.

    - veri kaybını önlemek için,
    - veriler ile işlem yapabilmek için,
    - veri türü karışıklığını çözebilmek için,
    - veri türü uyuşmazlığını giderebilmek için...

    tür dönüşümleri yapılır.

    not : ister değer aralığında olsun ister olmasın ne zaman alt türe dönüşüm yapmamız gerekse cast opertörü ile dönüştüreceğimiz türü bildirmemiz gerekir.

    detay : 

    int a = 3000 ;

    short s = (byte)a;  -----> burada int ifadesi byte türüne explicit edilmiş ve oluşan değer short türüne implicit edilmiştir.

/// checked ve unchecked 

    checked : explicit tür dönüşümü yapılırken runtime de bir hata fırlatılmasını sağlar. bu checked kullanılmaz ise herhangi bir hata almadan veri kaybı arka planda gerçekleşir.

    {
        veri kaybı potansiyeli olan dönüşüm kodları bu alana yazılır
    }

    unchecked : explicit tür dönüşümü yapılırken hata fırlatmadan uygulamanın çalışmaya devam etmesini sağlar. 

    NOT : tür dönüşümleri default olarak unchecked dir.

/// özel türler arasında tür dönüşümleri 

1- bool ile sayısal değerler arasında tür dönüşümü,
    elimizdeki mantıksal değer taşına bir veriyi herhangi bir sayısal veriye convert edersek ilgili değerin sayısal karşılığını elde ederiz.

    true ---> 1
    false ---> 0

    örnek : bool b = true;
        int i = Convert.ToInt32(b);

        Console.WriteLine(i);       ---> 1

        içerisinde true değeri taşıan b isimli boolean türündeki bir veriyi dönüştürdük.

2- sayısal değerler ile bool arasında tür dönüşümü,
    Elimizdeki sayısal değer taşıyan bir veiriyi mantıksal bir veriye convert edersek ilgili değerin mantıksal karşılığını elde ederiz.

    örnek : 
        short s = 1;
        bool a = Convert.ToBoolean(s);
        Console.WriteLine(a);       ---> true
    
    not : 0 dışındaki bütün değerlerin mantıksal karşılığı true dur.

3- char ile sayılar türler arasında tür dönüşümü,
    klavyede görünen her bir karakterin arka planda bir ASCII kodu vardır.


    ASCII kodları :

    A   B    C   D   E   F   G   H   İ   J   K   L   M   N   O   P   R   S   T   U   V  W   X   Y   Z 
    65  66  67  68  69  70   71 72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89


    a   b    c   d   e   f   g   h   ı   j   k   l   m   n   o   p   r   s   t   u   v   w   x   y   z
    97  98  99  100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121

    ASCII : bilgisayardaki her bir karakterin sayısal bir karşlığı vardır. bu sayısal değerlere ascii kodları denir.

    char türündeki herhangi bir veriyi integer veri türüne dönüştürmek istersek bize ascii kodlarını verir. tersi de mümkündür.
    

    örnek :
        char a = 'a';
        int b = (int)a ;
        Console.WriteLine(b);           ---> 97


        char a = '-';
        int b = (int)a;
        Console.WriteLine(b);           ---> 45

    bu tür dönüşümlerde explicit tür dönüşümü yapılır. 

4- sayılar türler ile char arasında tür dönüşümü.

    örnek;

        int deger = 97;
        char @char = (char)deger;
        Console.WriteLine(@char);           --->    a

// tür dönüşümleri genel konu tekrarı:

1- tür dönüşümlerini neden yaparız ?
    yazılım demek elde edilen verileri uygun algoritmalar yardımı ile doğru yöntem ve şekiller yardımı ile istenen çıktıyı oluşturmaktır. 
    veriler bu yolculuk esnasında bazı işlemlere tabi tutulurlar , bunlardan bir tanesi de tür dönüşümleridir.
    bu dönüşümlere veriler arasında karşılaştırma yapabilmek , veriler üzerine matematiksel işlemler yapabilmek , bellek optimizasyonu gibi sebeplerden ihtiyaç duyarız.

2- parse fonksiyonu nedir ne için kullanılır?
    sadece string ifadeler üzerinde çalışan bir fonksiyondur. string türe veya string türden bi dönüşüm olması durumunda kullanılır.

3- convert fonksiyonu nedir ne için kullanılır?
    bütün tür dönüşümlerinde çalışan bir fonksiyondur. 
    
4- sayılar türlü verilerin kendi aralarında tür dönüşümleri nelerdir?
    genel anlamda bellek optimizasyonu için kullanılır. byte türü 8 bit lik yer tutarken decimal 128 bit lik yer kaplamaktadır.
    byte ile tutulabilecek bir veriyi decimal ile tutarak gereksiz bellek kullanımına yol açmışız demektir.

5- implicit ve explicit tür dönüşümleri nasıl yapılır?
    implicit tür dönüşümü sayılar veri türlerinde daha geniş bir değer aralığı tutan verilere bilgisayar yardımı ile dönüştümeye denir. 
    bu dönüşümde developer ilave herahngi bir şey yapmasına gerek yoktur. 

    explicit tür dönüşümü sayısal verileri daha dar bir değer araşoğı tutan verilere dönüştürmeye denir.
    bu dönüşümde bilgisayarın herhangi bir sorumluluğu yoktur. bütün sorumluluk developer dadır. 
    burada dikkat edilmesi gereken nokta byte kapasitesini aşmayan bir değeri daha üst segmentte bir türde saklıyorsak ve bunu byte türüne dönüştürmek istersek 
    gene explicit tür dönüşümü yapmak gerekir. BİLGİSAYAR VERİNİN TÜRÜ İLE İLGİLENİR , VERİNİN DEĞERİ İLE DEĞİL...

6- checked ve unchecked kavramları?
    normal şartlarda bilinçli tür dönüşümlerinde herhangi bir hata ile karşılaşmadan arka planda işlemler gerçekleşir.
    burada bilinçli olarak tür dönüşümünde hata fırtlatmak istediğimiz bir durumda 'checked' olayını kullanabiliriz.

    checked
    {
        short @short = 300;
        byte @byte = (byte)@short;
        Console.WriteLine(@byte);
    }

    bu kodlar checked arasına yazılı olmasaydı herahangi bir hat görünmeden arka planda yapılacaktı. 

7- özel tür dönüşümleri ?
    bool - sayısal , sayısal - bool , char - sayısal , sayısal - char arasındaki tür dönüşümleridir.

    sayısal - bool dönüşümlerinde 0 harici bütün değerler true olarak gelir.
    sayısal-bool , bool-sayısal tür dönüşümleri convert ile yapılır.
    char-sayısal , sayısal-char tür dönüşümleri explicit olarak yapılır. ve sonuç olarak ascii kaynak kodlarını döner.

8- ascii kaynak kodları nedir ve ne işe yararlar ?
    klavyedeki her bir ifadenin ascii kaynak kodu karşılığı vardır. bu kodlar bilgiayar sistemlerinde sıkça kullanılırlar.

/// operatörler nedir ?

    bir işin sorumluluğunu üstlenen temel yapı taşlarıdır , bir operasyon gerçekleştirirler.

    bir operatör teorik olarak sağında ve solunda bulunan değerler üzerinde bir bağıntı oluştururlar.

    opertörler kullanılırken geriye dönüş değerlerine dikkat edilmelidir. 

    operatör çeşitleri;

    1- aritmatik operatörler,
    2- karşılaştırma operatörleri,
    3- mantıksal operatörler,
    4- özel işlemler operatörleri.
    5- metinsel ifalerde kullanılan operatörler.

1- matematiksel operatörler
    + , - , * , / , % 
    iki sayısal değer üzerinde işlem yapan operatörler oldukları için işlem neticesinde 'uygun' türde sonuç return ederler.

    oparetörler geriye hangi değer dönüreceğini visaul studio code özelliği gereği önizmele olarak bizlere söyler.

    not : aynı türde yapılan aritmatik işlemlerin sonucu gene aynı türde return edilir. bu noktada istisna olarak 2 tane byte türü arasınd yapılan işlemler 
    int türünde return edilmektedir. 2 farklı türde yapılan aritmatik işlemlerde sonuç büyük olan türde olacaktır.

    int x = 3;
    double y = 325;
    sonuc = x + y ;
    Console.WriteLine(sonuc)        ---> sonuç double türünde olacaktır.

    not : 2 'byte' türü arasında yapılan aritmatik işlemlerin sonucu 'int' türündedir.

2- karşılaştırma operatörleri,

    > , < , >= , <= , == 

    iki sayısal değer arasında büyüklük , küçüklük , eşitlik durumuna göre karşılaştırma yapan operatörlerdir.

    not : metinsel ifadelerdede == operatörü kullanılabilir.

    karşılaştırma operatörleri true ya da false döner.

3- mantıksal operatörler,
    && , || , ^ 
    tüm şartları değerlendirip kendine göre sonuç döndüren operatörlerdir. bu operatörler geriye bool değer döndürürler.

    || ile ^ arasındaki temel fark : 

    || operaötünde en az 1 adet true olması gerekir,
    ^ operatöründe 2 durumdan yanlızca 1 tanesi doğru olması gerekir.

    && (ve operatörü)
    true && true ---> true
    true && false ---> false
    false && true ---> false
    false && false ---> false

    || (veya opertörü)
    true || true ---> true
    true || false ---> true
    fasle || true ---> true
    false || false ---> false

    ^ (ya da operaötür) her 2 ihtimalden yanlız birisi gerçekleşecek.
    true ^ true ---> fasle
    false ^ true ---> true
    true ^ false ---> true
    false ^ false ---> false

4- özel işlemler operatörleri.
    ++ , -- , += , -= , *= , /= , ! , != 

    ++ , -- operatörleri : bir artırma veya 1 azaltmaya yarayan operatörlerdir.

    int i = 5;  ---> i ye 5 değerini atadık.
    i ++;   ---> compiler bunu (i = i+1) olarak okudu.

    i++ ile ++i arasındaki fark nedir ?

    ++i önce i değerini 1 artırır sonra i değerini return eder , i++ da ise önce i değerini return eder daha sonra değeri 1 artırır.

    Örnek : int i = 10;
    Console.WriteLine(i++);     ---> 10

    int i = 10 ;
    Console.WriteLine(++i);     ---> 11
        
    += , -= , *= , /= operatörleri : üzerine ekleme ve yığma oparetörleridir. tamamı aritmatik işlemlerde kullanılır. ilave olarak += operatörü metinsel ifadeler için de kullanılabilir.

    örnek : int i = 5;
    i += 4 ;
    Console.Writeline(i);       ---> 9

    int i = 5;
    i -= 1 ;
    Console.Writeline(i);       ---> 4

    int i = 5;
    i *= 2 ;
    Console.Writeline(i);       ---> 10

    int i = 5;
    i /= 2 ;
    Console.Writeline(i);       ---> 2

    ! operatörü : değil operatörü olarak bilinir. tek başına bir anlam ifade etmez, 

    ! operatörü kullanım örnekler;

    Console.WriteLine(!true);   ---> false
    Console.WriteLine(true);    ---> true

    Console.WriteLine(2 != 3 ); ---> true
    Console.WriteLine(3 != 3 ); ---> false

5- metinsel operatörler.

    + , += , == , !=

    + operatörü : metinsel ifadelerde birleştirme de yapan operötlerdir.

    string s1 = "adnan";
    string s2 = "Ziyagil";

    Console.WriteLine(s1+s2);       ---> adnanZiyagil

    += operatörü : bir metin üzerine başka bir metin ekleme yapan operatördür.

    string s1 = "adnan";
    string s2 = "Ziyagil";
    s1 += s2 ;              (tam bu noktada s2 değişkenini s1 değişkeni üzerine yığdık).
    Console.WriteLine(s1)  ---> adnanZiyagil

    == operatörü : 2 metinsel ifadeyi karşılaştırmak için kullanılır. sonuç olarak true veya false döner.

    string s1 = "adnan";
    string s2 = "Ziyagil";
    Console.WriteLine(s1==s1)  ---> false

    not : stirng ifadelerde > veya < karşılaştırma olarak kullanılamaz. 

    != operatörü : == ifadesinin tersini almada kullanılan operatördür. (eşit değilmi)

    string s1 = "adnan";
    string s2 = "Ziyagil";
    Console.WriteLine(s1!=s1)  ---> true

/// ternary operatörü : 

    kalıpsal bir operatördür ve çok fazla kullanılır. şarta bağlı değer döndüren bir operatördür.

    not : bir değişkene , değere, property e değer atarken , eğerki bu değer bir şarta göre fark edecekse satır bazlı / tek satırda bu şart kontrolünü yaparak 
    duruma göre değer döndürmemizi sağlayan kalıpsal bir operatördür

    not : ternary operaötür bir koşulu değerlendirir ve koşul doğru ise bir değeri , yanlış ise bir başka değeri döndürür.
        ternary opertörü if-else yapısının daha kısa bir  alternatifi olarak kullanılır.
    
    ternary operatörü 3 kısımdan oluşur.

    1- koşul : koşulu değerlendiren bir ifade (bool türünde olmalı),
    2- eğer doğruysa : koşul doğru ise döndürülecek değer,
    3- eğer yanlışsa : koşul yanlışsa döndürülecek değer.

    ___________________________ ? ___________________________: ___________________________;
    (bool sonuç üretecek alan)      (true ise dönecek alan)     (false ise dönecek alan)
   
    terbary operaötür ile yapılabilecek işlemler ,

    1- karşılatırmalar,
    2- atama işlemleri,
    3- döndürme işlemleri,
    4- null kontrolü,


    1- karşılaştırma :

     örnek :
        int i1 = 100 , i2 = 200;
        int max = (i1>i2) ? true : false;
        Console.Write(max);         ---> false

    2- atama : 
        int i1 = 100 , i2 = 200;
        int max = (i1>i2) ? i1 : i2;
        Console.Write(max);         ---> 200

    3- döndürme :
        int i1 = 100 , i2 = 200;
        int max = (i1>i2) ? i1 : i2;
        Console.Write(max);         ---> 200

    4- null kontrolü :
        string value = "hello world!";
        string result = value == "" ? value : "null";
        Console.WriteLine(result);          ---> hello world!

        bu kontrolün özelleştirilmiş bir hali vardır. şöyle ki,

        string value = "hello world!";
        string result = value ?? "null";
        Console.WriteLine(result);          ---> hello world!

    if-else yapısı ile ternary karşılaştırması :

    if-esle yapısı :

    bool medeniHal= true;

    if (medeniHal == true)
    {
        Console.WriteLine("Evlilere Kampamya");
    }
    else
    {
        Console.WriteLine("Bekarlara Kampanya");
    }

    ternary yapısı :

    bool medeniHal= true;

    string message = (medeniHal == true) ? "Evlilere Kampanya" : "Bekarlara Kampanya" ;

    Console.WriteLine(message);

    not : ternary operatöründe her iki ihtiamlde de döndürülecek değer aynı olmak zorundadır. if else yapısında döndürülecek sonuçlar farklı türlerde olabilir.

    ternary örnek :

    yaşı 25 den küçük olanlara A,
        25 e eşit olanlara B,
        25 den büyük olanlara C değerini döndüren bi ternary operatörü oluşturalım.

    int yas = 32;

    string sonuc = (yas<25) ? "A" : ((yas==25)? "B":"C");  
    Console.WriteLine(sonuc);           ---> c

/// assign operatörü

    atama operatörlerinde sağ-sol önemlidir. 
    eğer değişken sol tarafta çağırılıyor ise değişkenin kendisi , sağ tarafta çağırılıyorsa değişkenin taşıdığı değer gelir.

    not : assign operatörü bazı durumlarda davranış değiştirerek referans etme davranışı sergileyebilir.

/// member access (üye erişim operatörü ".")

    elimizdeki değerlerin türleri alt elemanlara sahiptir. bu alt elemanlara ulaşmak için "." operatörü kullanılır.

    üye erşimi ne demektir ?

    -   bir nesnenin veya sınıfın üyelerine erişmek için kullanılan bir işlemdir.

    not : "." operetörü bir nesnenin üyelerine erişmenin yanında static üyelere erişmek için de kullanılabilir.

    not : static üyeler nesne özellikleri oluşturmadan erişilebilen sınıf üyeleridir.

    int a = 5;

    a.CompareTo
    .Equals
    .GetHashCode
    .GetType
    .GetTypeCode
    .ToString
    .TryFormat

    buradaki "." operatöründen sonra gelenler int türüne ait member access lerdir.

    string b = "ali";

    b.Aggregate
    .All
    .Any
    .Append
    .AsEnumerable
    .AsMemory
    .AsParallel
    .
    .
    .

    buradaki "." operatöründen sonra gelenler string türüne ait member access lerdir.

/// cast operatörü 

    daha mnce cast operatörlerini 3 yerde gördük

    1- boxing edilmiş bir veriyi unboxing ederken,
    2- explicit tür dönüşümünde 
    3- char - sayısal özel tür dönüşümlerinde (ASCII Kodlarını verirdi)
    4- polimorfizm durumunda base class referansı ile işaretlenen bir nesneyi kendi türünde elde edebilmemizi sağlamaktadır. (ileride göreceğiz)

/// sizeof operatörü:

    bir verinin veya ifadenin bellekte ne kadar yer kapladığını integer olarak geriye döndüren operatördür. (kaç byte olduğunu verir.)

    Console.WriteLine(sizeof(byte));    ---> 1
    Console.WriteLine(sizeof(sbyte));   ---> 1
    Console.WriteLine(sizeof(int));     ---> 4
    Console.WriteLine(sizeof(uint));    ---> 4
    Console.WriteLine(sizeof(double));  ---> 8
    Console.WriteLine(sizeof(decimal)); ---> 16
    Console.WriteLine(sizeof(float));   ---> 4
    Console.WriteLine(sizeof(char));    ---> 2
    Console.WriteLine(sizeof(long));    ---> 8

/// typeof operatörü :
    bir veri veya ifadenin türünü döndürmek için kullanılan operatördür. türü tespit etmek için kullanılır.


    /// default operatörü :

    herhangi bir operatörün default değerini döndüren bir operatördür. 

    default değer nedir ?

    - geçerli her tür için yazılım tarafından varsayılan olarak tanımlanmış değerdir.

    Console.WriteLine(default(decimal));    ---> 0
    Console.WriteLine(default(string));     ---> null
    Console.WriteLine(default(short));      --->0
    Console.WriteLine(default(byte));       --->0
    Console.WriteLine(default(long));       --->0
    Console.WriteLine(default(int));        --->0
    Console.WriteLine(default(byte));       --->0
    Console.WriteLine(default(char));       ---> null

    herhangi bir değişkene default değer atamak için;

    short a = default;
    int b = defaul;
    string c = default;

/// is operatörü :

    asıl kıllanım amacı boxing işlemine tabi tutulmuş herhangi bir değerin öz türüne ulaşmaktır.
    is operatörü denetleme neticesinde boolean türünde değer döndürür.

    object @object = true;

    Console.WriteLine(@object is null);     -->False
    Console.WriteLine(@object is Program);  -->False
    Console.WriteLine(@object is int);      -->False
    Console.WriteLine(@object is null);     -->False
    Console.WriteLine(@object is bool);     -->True

/// is null operatörü

    bir değerin null olup olmmadığnı kontrol etmek için kullanılan ve geriye boolean değer döndüren opeartördür.

    örnek :

    string @string ="abcd";
    string @string2 ="";
    Console.WriteLine(@string is null);         ---> false
    Console.WriteLine(@string2 is null);        ---> True


    not : 'is null' operatörünü sadece nullable olan değerler için kullanabiliriz.

    not2: 2 tür değişken vardır.

    1- değer türlü değişkenler : bunlar null olamazlar.
    2- referans türlü değişkenler : bunlar null olabilirler. (string referans türlü bir değişkendir.)

/// 'is not null' 
    is null ile aynı görevlere sahiptir.

/// as operatörü:
    cast operatörüne alternatif olarak üretilmiştir. dönüşümlerde kullanılır.

    cast operatörünü sadece 3 alanda kullanabiliyorduk.

    1- boxing edilmiş bir veriyi unboxing ederken,
    2- explicit (bilinçli) tür dönüşümünde 
    3- char - sayısal özel tür dönüşümlerinde (ASCII Kodlarını verirdi)
    4- polimorfizm durumunda base class referansı ile işaretlenen bir nesneyi kendi türünde elde edebilmemizi sağlamaktadır. (ileride göreceğiz)

    buradaki maddelerden 1.madde olan boxing-unboxing durumuna alterantif olarak türetilmiştir.

    cast operötür ile boxing içerisinden everi alırken içerisindeki verinin türüne uygun bir değişkene atama yapmak gerekirdi. 
    aksi halde hata alarak uygulamanın sonlanmasına sebebiyet verir.
    as operatörü bu hatayı almamızı engelleyerek null değer dönüdrür. işlem gene yapılmaz ancak hata alarak programın durmasının önüne geçilmiş olur.

    örnek : 

    1- cast operatörü yardımı ile boxing edilmiş bir veriyi unboxing yaptık.

    object @object = 123;
    int a = (int)@object;   

    2- as operatörü yardımı ile boxing edilmiş bir veriyi unboxing yaptık.

    object @object = 123;
    Type a = @object as Type ;

    önemli not : 

    as operaötörü kullanımlarında tür uygun olmadığında geriye null değer döndürür. 
    geri döndüreeği null değerini karşılayabilecek bir tür ile karşılanmak isteyecektir.
    buradaki ihtiyaca istinaden şunu söyleyebiliriz.
    "as operatörü değer türlü değişkenler için kullanılamaz!"

    detaylı örnek :

    object @object = "ahmet";
    string @object2 = (string)@object;

    Console.WriteLine(@object);         ---> ahmet

    object türü referans türlü olduğundan dolayı string ile cast edilmesinde herahangi bir hata ile karşılaşmadık.


    object @object = "ahmet";
    int @object2 = @object as int;

    Console.WriteLine(@object);         ---> hata verdi.
    Console.WriteLine("hello!!");       ---> hello!!

    hatanın sebebi ise @object içerisinde taşınan değer string bir ifadedir. biz bunu int içerisine koymaya çalıştık. hata verip kapandığı için 'hello!!' ekrana yazılmadı.


    object @object = "ahmet";
    Program @object2 = @object as Program;

    Console.WriteLine(@object2);        ---> null
    Console.WriteLine("hello!!");       ---> hello!!

    yukarıdaki koddan farklı olarak burada referans türlü bir değişkene atamaya çalıştık. int değer türlü değişken olduğundan veri ile uyumlu olması gerekirdir.
    ancak referans türlü bir değişkene atanması durumunda null değer döndürebiliyoruz.
    bu kod parçasına 2.satırda @object 'program' türünde mi diye sorduk. eğer 'program' türünde ise @object değerini ekrana bastıracaktı. değilse null dönecek. ve uygulamaya çalışmaya devam ederek 'hello!!' yazısı bastırılmış oldu.
    as ile bu işlemi yapmamızın avantajı program sonlanmadan bu işlemi yapabiliyoruz. 
    cast ile aynı işlemi yapmaya çalışsak program hata verip kapanacaktır.

/// nullable opearötürü(?) 

    c# programlama dilinde değer türlü değişkenler normal şartlarda null değer alamazlar.
    bir değer türlü değişkenin null değer alabilmesi için nullable opeartörünün (?) kullanıması gerekir.

    int a = null;  (böyle bir satır hemen hata verir. bunu yapmamız program tarafından engellenmiştir.)
    int? a = null; (bu şekilde ? ilavesini yaparak nullable olabilen olarak yolumuza devam edebiliriz.)

    ayrıntı detay :

    object x = 123;
    int y = x as int;

    normal şartlar altında bu şekilde işlem yapılamaz. çünkü as operötürünün çalışma mantığına göre null değer alabilen değerlere dönüşüm yapmak gerekir.
    int null alabilen bir değişken türü değildir.

    as çalışma mantığında 2 seçenek vardır.
    1- bir değer döndürecek
    2- null değer döndürecek
    c# object türü içerisindeki değer ile ilgilenmez. 123 normal şartlarda int olabilir ancak programın çalışma mantığında değer ile ilgilenme yoktur. object türü boş bir değer de taşıayabilir.
    bu sebepten dolayı null değer alabilen değişken türleri ile çalışmak ister bizim object.

    yukarıdaki işlemde oluşan hataya sebep programın durmaması için kodları şu şekilde düzeltmemiz gerekir.

    object x = 123;
    int? y = x as int?;

    burada int? nullable olduğundan dolayı object in gönlü oldu ve yola devam ediyoruz.

/// null-coalescing opearötürü (??)

    elimizde null olan bir değişken var ise null içerisine herhangi bir değer gönderebilmemizi sağlayan operatördür.

    örnek:

        string a = null;
        Console.WriteLine(a ?? "merhaba") ;

        a null değil ise a değerini yazdır , null ise "merhaba" yazdır dedik. 

    daha önceki derslerde gördüğümüz teranry operaötür ile de bunu yapabilirdik.

    Console.WriteLine(a ?? "merhaba") ;
    Console.WriteLine(a ==null ? "merhaba": a);

    örnek2: 
        string a = "kemal";
        Console.WriteLine(a ?? "merhaba") ;

        bu kod parçasında;
        eğer a ifadesi null ise "merahaba" yazdır değil ise a ifadesini yazdır dedik. buradan yola çıkarak '??' operaötür kullanılırken her 2 veri de aynı türde olması gerekir.
        string bir değişkenin null olup olmadığını kontrol ediyorsak null olması durumunda elimize aynı türde başka bir veri geçmeli.
        işlem sonucu olarak elimize elimize int türünde veya bool türünde bir veri geçmemeli.

/// null-coalescing assignment (??=)

    c# 8.0 ile gelen bir özelliktir.
    amacı değeri null olan bir değişkeni hem ekrana bastırırken hem de devamında null yerine değer ataması yapmış oluyoruz.

    karşılaştırmalı örnek:

    string isim = null ;
    Console.WriteLine( isim ?? "merhaba");      ---> ?? operatörü kullandığımız için null olan değere karşılık "merhaba" ifadesi ekrana basıldı.
    Console.WriteLine(isim);                    ---> ?? operatörü kullandığımızdan için kodun devamındaki çağırmalarda "merhaba" yazmayacak.

    string isim1 = null ;
    Console.WriteLine( isim1 ??= "merhaba");    ---> ??= operatörü kullandığımız için null olan değere karşılık "merhaba" ifadesi ekrana basıldı.
    Console.WriteLine(isim1);                   ---> ??= operatörü kullandığımız için null olan değere karşılık "merhaba" ifadesi ekrana basılacak.

    örnek :

    int? id = null;                             ---> normal şartlarda int null almaz, ? operatörü yardımı ile nullable özelliği kazandırdık.
    Console.WriteLine(id ?? 1);                 ---> ?? operatörü kullandığımız için null olan değere karşılık 1 ifadesi ekrana basıldı.
    Console.WriteLine(id);                      ---> ?? operatörü kullandığımız için kodun devamındaki çağırmalarda 1 yazmayacak.

    int? id = null;                             ---> normal şartlarda int null almaz, ? operatörü yardımı ile nullable özelliği kazandırdık.
    Console.WriteLine(id ??= 1);                ---> ??= operatörü kullandığımız için null olan değere karşılık 1 ifadesi ekrana basıldı.
    Console.WriteLine(id);                      ---> ??= operatörü kullandığımız için kodun devamındaki çağırmalarda 1 yazacak.

/// operatörler ile ilgili özetler

    1- operatör nedir ?
    2- operatör okuryazarlığı
    3- aritmatik operatörler
    4- aritmatik operatörlerde geriye dönüş değeri
    5- (int)*(double) = ?
    6- (byte)*(int) = ?
    7- (byte)*(byte) = ?
    8- matematiksel işlemler(öncelik sırası)
    9- karşılaştırma operatörleri
    10- karşılaştırma operatörlerinde geriye dönüş değerleri
    11- mantıksal operatörler
    12- mantıksal operatörlerin kullanım mantığı
    13- mantıksal operatörlerin geriye dönüş değerleri
    14- arttırma-azaltma operatörleri
    15- üzeine ekleme / yığma operatörleri
    16- aynı için farklı opratörler ile yapılması
    17- metinsel operatörlerde + operatörü
    18- metinsel operatörlerde += operatörü
    19- metinsel operatörlerde == operatörü
    20- diğer operatörler
    21- ! operatörü
    22- ternary operatörü
    23- birden fazla condition uygulama
    24- atama operatörün
    25- member-access operatörü
    26- cast opearötürü
    27- sizeof operatörü
    28- typeof operatörü
    29- default operatörü
    30- is operatörü
    31- is null operatörü
    32- is not null operatörü
    33- as operatörü
    34- ? nullable operatörü
    35- ?? null coal escing operatörü
    36- ??= operatörü

/// akış kontrol mekanizmaları

    belirli şartlara göre akışın yönünü değiştiren mekanizmalardır.


    1- switch-case yapısı
    2- if elif else yapısı

    temel farklar
    1- switch yapısı bir değişkenin veya ifadenin değerine göre farklı işlemler gerçekleştirir. if-elif-else yapısı ise bir koşulun sonucuna göre farklı eylemler gerçekleştirir.

    2- switch-case yapısı birden fazla koşulu kontrol edebilir , if-elif-else yapısı yanlızca 1 koşulu kontrol edebilir.

    3- switch yapısı daha okunaklı olabilir , if-elif-else yapısı daha karmaşık koşullar için daha uygun olabilir.

    switch-case yapısı : 

    kodun akışında belirli bir şarta göre yönlendirme yapmamızı şu şekillerde sağlayabilir.

    1- farklı bir algoritma çalıştırabiliriz.
    2- farklı bir operasyon gerçekleştirebiliriz.
    3- bir olayı tetikleyebiliriz.

    not : bir switch-case yapılanmasında bir değişken sadece eşitlik(=) durumu üzerinden kurgu yapılabilir. => , =< , < , > gibi ifadeler üzerinde işlem yapamaz.

    switch case prototipi

    switch(.......A.....)
    {
        case B1:
        //kodlar
        //kodlar
        break;
        case B2:
        //kodlar
        //kodlar
        break;
        case B3:
        //kodlar
        //kodlar
        break;
        default:
        //kodlar
        //kodlar
        break;
    }


    A : süreçte eşitlik durumu kontrol edilecek değer.
    not : her bir case bir adımı temsil etmektedir. case içerisindeki şart sağlanırsa break ile switch sonlanır ve kod akmaya devam eder.
    B : A ile eşitlik durumlarında kontrol edilen değerler.
    not2 : case ile break keywordleri arasında yazılı olan kodlar case in doğrulanması sürecinde işlenecek kodlardır.
    not3 : hiç bir case durumu sağlanmıyorsa bir 'default' keywordu yardımı ile kodlar çalıştırılır. 'default' kalıbı zorunlu değildir. olmasa da olur.

    örnek : 
    string p = "ahmet";

    switch (p)
    {
        case "mehmet":
        Console.WriteLine("adı mehmettir");
        break;

        case "ozan":
        Console.WriteLine("adı ozan");
        break;
        
        case "cem":
        Console.WriteLine("adı cem");
        break;

        default:
        Console.WriteLine("ismi bilemedik");
        break;
    }

    // sonuç olarak "ismi bilemedik" dedi.

    notlar :

    1- kontrol edilen verinin türü ne ise case türleride o türde olmalıdır.
    2- case ile yazılan ifadeler sabit olmalı. herhangi bir değişken kabul edilemez. 
        örnekte "p" üzerindne işlem yaptık ancak string p = "ahmet"; satırını iptal ederek switch("ahmet") olarak da yazabilirdik. ancak case alanına "mehmet" yerine herhangi bir değişken yazamayız.
    3- default satırı switch in en sonunda olmayadabilir."default" yazısı ile en son çalışması gerektiğini vermiş olduk. aynı durum case blokları için de geçerlidir. herhangi bir sıralama önemli değildir.

    switch case içerisinde when şartı :

    switch case yapılanmasında sadece elimizdeki değerin eşitlik durumu üzerinden işlem yapabiliriz. bunu dışında işlem işlem esnasında farklı şartları da değerlendirmek istiyorsak 'when' kulllanmamız gerekir.
    not : sadece 1 adet when ekleyebiliriz.
    not2: when içerisinin boolean türünde olması gerekir.
    örnek :
   
    int satisTutari = 1000;

    switch (satisTutari)
    {
        case 100 when (true):
        Console.WriteLine("1");
        break;
    }

    switch case içerisinde go to şartı :

    switch-case yapılanmasında sadece eşitlik durumu incelendiğinde mantıksal bir işlem gerçekleştirememekteyiz.
    herhangi 2 case neticesinde aynı kodların çalışması istenecekse aynı kodları tekrar yazmak yerinde "go to" kullanırız.

    yapı : 

    switch (value)
    {
        case A :
        A işlemini yap;
        break;
        case B :
        B işlemini yap;
        break;
        case C :
        A işlemini yap;
        break;
    }
        birden fazla kontrol yapamadığımızdan bu yapılanmaya gittik. switch edilen değer hem A hem C değerlerine eşit olması gereken bir durum ile karşılaşabilriiz. 
        burada kod tekrarından kaçmak için "go to" kullanmak gerekir.

        örnek : 

        int i = 10;
            switch(i)
            {
                case 5:
                Console.WriteLine(i*10);
                break;
                case 7:
                Console.WriteLine(i*7);
                break;
                case 10:
                Console.WriteLine(i*10);
                break;
                default:
                Console.WriteLine(i*10);
                break;
            }

        analiz : i değerine 10 verdik. eğer değer 5 ise 10 ile çarp , 7 ise 10 ile çarp , 10 ise 10 ile çarp , hiç bir case geçerli değilse de 10 ile çarp dedik. tekrar eden kısımlara "go to" kullanalım.


        int i = 10;
            switch(i)
            {
                case 5:
                Console.WriteLine(i*10);
                break;

                case 7:
                Console.WriteLine(i*7);
                break;

                case 10:
                go to case 5;

                default:
                go to case 5;
            }
    
    switch expressions:

    c# 8.0 ile birlikte gelen bir yapılanmadır. yapılanmanın amacı uzun uzadıya switch yapısından kurtuluk daha az satır ile sonuca ulaşmaktır.
    bu işlem case ile break arasında tek bir satırlık işlem yapılıyorsa geçerlidir. 

    örnek :

        string mesaj = "";

        switch(DateTime.Now.DayOfWeek)
        {
            case DayOfWeek.Monday:
            mesaj = "bugün pazartesi";
            break;
            case DayOfWeek.Tuesday:
            mesaj = "bugün salı";
            break;
            case DayOfWeek.Wednesday:
            mesaj = "bugün çarşamba";
            break;
            case DayOfWeek.Thursday:
            mesaj = "bugün perşembe";
            break;
            case DayOfWeek.Friday:
            mesaj = "bugün cuma";
            break;
            case DayOfWeek.Saturday:
            mesaj = "bugün cumartesi";
            break;
            case DayOfWeek.Sunday:
            mesaj = "bugün pazar";
            break;
        }

        Console.WriteLine(mesaj);

        analiz : "mesaj" isminde , string türünde ram da bir alan tahsis ettik.
                DateTime.Now.DayOfWeek ile haftanın günlerini belirledik. ve mesaj değişkeni içerisine attık.

        switch expressions kullanılmış hali :

        string mesaj = DateTime.Now.DayOfWeek switch
        {
            DayOfWeek.Monday => "bugün pazartesi",
            DayOfWeek.Tuesday => "bugün salı",
            DayOfWeek.Wednesday => "bugün çarşamba",
            DayOfWeek.Thursday => "bugün perşembe",
            DayOfWeek.Friday => "bugün cuma",
            DayOfWeek.Saturday => "bugün cumartesi",
            DayOfWeek.Sunday => "bugün pazar",
            _ => throw new NotImplementedException(),
        };
        Console.WriteLine(mesaj);

        not : DateTime.Now.DayOfWeek ifadesi, mevcut zamanın haftanın hangi gününe karşılık geldiğini belirten bir DayOfWeek enum değeri döndürür. 
        DayOfWeek enumu, haftanın günlerini temsil eden bir türdür ve Pazartesi'den Pazar'a kadar olan günleri içerir.

        enum nedir? 
        enum, C# (ve birçok diğer programlama dilinde) bir türdür ve belirli bir değeri temsil eden bir sabit küme oluşturmak için kullanılır. 
        "enum" kısaltması, "enumeration" yani "sıralama" kelimesinden gelir. Enumerations, genellikle bir dizi benzersiz değeri temsil etmek için kullanılır.
    örnek2:

    eski yöntem ile ;

    string isim = "";
    int i = 10;

    switch(i)
    {
        case 5 :
        isim = "hilmi";
        break;
        case 7 :
        isim = "rıfkı";
        break;
        case 10:
        isim = "cem";
        break;
    }
    Console.WriteLine(isim);

    yeni yöntem ile;

    int i = 10;
    string isim = i switch
    {
        5=>"hilmi",
        7=>"rıfkı",
        10=>"cem"
        _ => throw new NotImplementedException(),     /// bu satır default yerine geçiyor.
    };
    Console.WriteLine(isim);

/// when şartı ile switch expressions

    örnek: eski yöntem

    int b = 10;
    string uzay = "";

    switch (b)
    {
        case 5 when (true):
        uzay = "hilmi";
        break;
        case 7 when(2==2):
        uzay = "rıfkı";
        break;
        case 10 when(3==3):
        uzay = "cem";
        break;
    }
    Console.WriteLine(uzay);

    örnek : yeni yöntem-1

        int i = 10;
    string isim = i switch
    {
        5 when (false)=>"hilmi",
        7 when (4==4)=>"rıfkı",
        10 when (2==3)=>"cem",
        10 when (3==3)=> "doğru",
        _ => throw new NotImplementedException(),     /// bu satır default yerine geçiyor.
    };
    Console.WriteLine(isim);

    örnek : ynei yöntem-2

    int a=10;
    string isim = a switch
    {
        var b when a==7 && a%2==1 => "rıfkı",
        var b when a==10 && a%2==0 => "rıfkı2",
        var b =>"hiçbiri"       // _ => throw new NotImplementedException(),  // bu satırdaki her 2 kodda default anlamı taşır.
    };
    Console.WriteLine(isim);

    not-1 : eğer 2.yöntemdeki gibi 'var' keywordu ile bir değişken tanımlanması gerçekleştiriyorsak sabit bir eşitlik durumu kontrol ettiğimiz değeri ( bu örnekteki 7,10 değerlerini) çat diye yazamayız.
    not-2 : 2.yöntemde b değeri case de manuel olarak girilen değere tekabul etmektedir.
    not-3 : b değeri kullandığımız için manuel değer veremiyoruz.
    not-4 : 'var' zorunlu bir keyword değil. değerine türüne uygun bir değişekn ile tanımlama yapmamız mümkündür.

/// tuple patterns

    açıklama : tuple patterns switch yapılanmasını tuple nesnelerini kontrol edebilecek şekilde standart ve yeni yapılanmayla bizlere sunmaktadır.

    örnek : eski yöntem

    string adi = "nevin";
    int yasi = 32;
    string mesaj="";

    switch (adi , yasi)
    {
        case ("hüseyin" , 20):
        mesaj = "hoşgeldin Hüseyin";
        break;
        case("cansu",23):
        mesaj="hoşegldin cansu";
        break;
        default:
        mesaj="tanımlanamadı";
        break;
    }
    Console.WriteLine(mesaj);       // tanımlanamdı.

    örnek : yeni yöntem 

    string adi2 = "nevin";
    int yasi2 = 32;
    string mesaj2=(adi2 , yasi2) switch 
    {
        ("hüseyin" , 20) => mesaj2 = "hoşgeldin Hüseyin",
        ("nevin",32) =>    mesaj2="hoşegldin nevin",
        _ => throw new NotImplementedException(),
    };
    Console.WriteLine(mesaj2);      

    analiz : eski yöntemde klasik case break keywordleri vardı , yeni yöntemde case ve break yerine => sembolü kullanılıyor.

    önemli not : öncedek switch case break ile tek bir değeri kontrol edebiliyorduk , şimdi işler değişti if yapılanmasından daha efektif hale geldiği noktalar oluştu.

    örnek : eski yöntem

    int s1 = 10;
    int s2 = 20;

    string mesaj ="";

    switch (s1,s2)
    {
        case (5,10):
        mesaj ="sayılar 5 ile 10";
        break;
        case(10,20):
        mesaj="sayılar 10 ile 20";
        break;
        default:
        mesaj="sayıları bilemedik.";
        break;
    }

    Console.WriteLine(mesaj);           // sayıları  10 ile 20


    örnek yeni yöntem :

    int s1 = 10;
    int s2 = 20;

    string mesaj =(s1,s2)
    switch 
    {
        (5,10) => mesaj ="sayılar 5 ile 10",
        (10,20) =>mesaj="sayılar 10 ile 20",
        _ => throw new NotImplementedException(),
    };

    Console.WriteLine(mesaj);

/// when şartı ile tuple patterns

    örnek : eski yöntem

        string adi = "nevin";
        int yasi = 32;
        string mesaj=(adi , yasi)

        switch 
        {
            ("hüseyin" , 20) => mesaj = "hoşgeldin Hüseyin",
            ("cansu",23)=> mesaj="hoşegldin cansu",
            _ => throw new NotImplementedException(),
        };
        Console.WriteLine(mesaj);

    örnek : yeni yöntem :

    string adi = "nevin";
    int yasi = 32;
    string mesaj=(adi , yasi)

    switch 
    {
        var a when a.adi=="hüseyin" && a.yasi== 20 => mesaj = "hoşgeldin Hüseyin",
        var a when a.adi=="cansu" && a.yasi==21 => mesaj="hoşheldin cansu",
        var a when a.adi=="nevin" && a.yasi==32 => mesaj="hoşgeldin nevin",
        _ => throw new NotImplementedException(),
    };
    Console.WriteLine(mesaj);

    önemli not : daaha önceki derslerde değişken tanımlarken herhangi bir değer alabilir (int,byte,bool vs.) demiştik , ancak tuple da bu dğişkeni sadece var ile karşılayabiliriz.

/// positional patterns 

    positional patterns ise deconstruct özelliği olan mesmeleri kıyaslamak veyahut değersel olarak karşılaştırmak için kullanılan bir gelişimdir.

/// when kullanarak positional patterns     

    diğer whenler ile aynı mantıkla çalışır.

/// property patterns

    nesnenin propertylerine girerek belirli durumları hızlı bir şekilde kontrol etmemizi gerçekleştiren ve bunu farklı değerler için birden fazla kez tekrarlı bir şekilde yapmamıza olanak sağlayan güzel bir gelişimdir.

/// when kullanarak property patterns

    diğer whenler ile aynı mantıkla çalışır.

/// ifyapısı

    switch yapısında sadece eşitlik durumlarına göre kontrol sağlanabilirken if-elif-else yapılanmasında ise bütün durumlarda (<,>,=>,=<) kontrol sağlamak mümkündür.
    switchi kapsar ve mantıksal operatörler neticesinde oluşan sonuçları da kıyaslayabilir.

    prototip

    if(şart)
    {
        şart true ise burası tetiklenir
    }
    şart false ise ifden çıkıp yola kod yola devam eder.


    not1: if yapılanması tek başına kullanılıyorsa sadece şarta bağlı çalışacak koda odaklanır.
    not2: esle kullanmasak , sadece if kullansak bile olur,
    not3: bool türündeki değişkenlerin değerleri zaten bool olduğu için;
        if (medeniHal==true) yerine if(medeniHal) yazmamız yeterlidir.

/// if-else yapılanması

    sadece if yapılanmasında bir şarta göre kontrol yap değilse yola devam et diyorduk , if-else yapısında ise bir şarta göre kontrol yap , değilse else kısmındaki davranışları yap diyoruz.

    prototip

    if(şart)
    {
        şart true ise burası çalışacak
    }
    else
    {
        şart true değil ise burası çalışacak.
    }

    not : if yapılanmasında şaft false ise if den çıkıp yola devam ediyordu , if - else yapısında ise else komutları devreye giriyor.
    not2 : if ile else aynı anda tetiklenemez.

    her 2 durumda da (if durumu veya else durumu) aynı kod parçalarını kullanabiliriz. 

    örnek :

    int i = 10;
    if(i==10)
    {
        Console.WriteLine("i değeri 10 dur");
        Console.WriteLine("merhabalar");        // tekrar eden kod parçası
    }
    else
    {
        Console.WriteLine("i değeri 10 değildir.");
        Console.WriteLine("merhabalar");        // tekrar eden kod parçası
    }


    int i = 10;
    if(i==10)
    {
        Console.WriteLine("i değeri 10 dur");
    }
    else
    {
        Console.WriteLine("i değeri 10 değildir.");
    }

    Console.WriteLine("merhabalar");        // tekrar eden kod parçasını buraya aldık. "don't repeat your self" prensibinden yola çıkarak.

/// if-else if yapılanması.

    if-else yapısı sadece 2 durumda kontrol yapabiliyordu. kontrol edilen şart true ise if bloğu içerisindeki kodlar çalışır, kontrol edilen şart false ise else bloğundaki kodlar çalışırdı.

    if - else if yapılanmasında ise 3 veya daha fazla durumu kontrol edebiliriz.

    prototip

    if(şart1)
    {
        şart1 true ise bu bloktaki kodlar çalışacak.
    }
    else if(şart2)
    {
        şart2 true ise bu bloktaki kodlar çalışacak.
    }
    else if(şart3)
    {
        şart3 true ise bu bloktaki kodlar çalışacak.
    }
    else
    {
        şart1 , şart2 , şart3 false ise bu blokraki kodlar çalışacak.
    }

    not1: if-else if yapısı else olmadan da çalışır. kontrol edilen şartın sağlantığı ilk else if bloğundaki kodlar tetiklenir ve kod if else if yapılanmasından çıkarak yola devam eder.

    not2: kontrol edilecek bir şart her 2 durum için de geçerli ise else if de ilk yazılan şartı sağladıktan sonra kod if-else if bloğunu terk ederek yola devam eder.

örnek :

    int sayi = 250;

    if (sayi>100 && sayi<=200)
    {
        Console.WriteLine("100 ile 200 arasındadır.");
    }
    else if(sayi>200 && sayi<=300)
    {
        Console.WriteLine("200 ile 300 arasındadır.");
    }
    else if (sayi>200 && sayi<=300)
    {
        Console.WriteLine("200 ile 400 arasındadır.");
    }
    else
    {
        Console.WriteLine("hata1");
    }

    analiz : buradaki 250 değeri hem 200-300 arasında olma şartını hem de 200 - 400 arasında olma şartını sağlıyor. sağlanan ilk şartta kodlar çalıştı (burada konsola yazı yazdırdık) ve if yapısını terk etti.

/// scopesuz if yapısı

    bütün if - else if - else yapıları için geçerlidir.

    not : tek bir satırlık işlemlerde kullanılır.

    if(true)
    {
        Console.WriteLine("a");
    }

    alternatif :

    if(true) Console.WriteLine("b");   // çıktı ekranına b değerini verir.

    if (true) Console.WriteLine("b1");
    Console.WriteLine("c1");        // çıktı ekranına b1 ve c1 değerlerini verir ancak c1 değeri if şartından başımsızdır.

    not : birden fazla konsept var ise { } içerisine yazmak gerekir.

/// örnek1 klavyden girilen 2 ürünün fiyatı girildiğinde toplam tutar 200 tl den fazla ise 2.ürüne %25 indirim yaparak toplam tutarı gösteren bir uygulama.

    Console.Write("Lütfen Birinci Ürünün Fiyatını Giriniz: ");
    int fiyat1 = Convert.ToInt32(Console.ReadLine());
    Console.Write("Lütfen ikinci Ürünün Fiyatını Giriniz: ");
    int fiyat2 = Convert.ToInt32(Console.ReadLine());

    int toplam1 = fiyat1 + fiyat2;
    int toplam2 = fiyat1 + fiyat2*3/4;
    if ((fiyat1+fiyat2)>200)
    {
    Console.WriteLine(toplam2);
    }
    else
    {
        Console.WriteLine(toplam1);
    }

/// Örnek2 : belirlenen kullanıcı adı ve parola doğru girildiğinde "giriş başarılı" , yanlış girildiğinde "kullanıcı adı veya şifre hatalı" mesajı veren bir console uygulaması.

    string kullaniciAdi = "kullanıcı";
    string parola = "12345";

    Console.Write("Lütfen Kullanıcı adını giriniz : ");
    string? girilenKullaniciAdi = Console.ReadLine();           // buradaki ? ile string ifadeyi nullable yaptık.

    Console.Write("lütfen parola giriniz : ");
    string? girilenParola= Console.ReadLine();                  / buradaki ? ile string ifadeyi nullable yaptık.

    if ( kullaniciAdi == girilenKullaniciAdi)
    {
        if (parola==girilenParola)
        {
            Console.WriteLine("giriş başarılı");
        }
        else
        {
            Console.WriteLine("parola hatalı");
        }
    }
    else
    {
        Console.WriteLine("kullanıcı adı hatalı");
    }

    kritik1 : tek satırlık işlem yaptığımız için { } leri kaldırabiliriz.
    kritik2 : true olması durumunda if bloğu çalışacaktı. "!" ile false olması durumunda if bloğunu çalıştırabiliriz.
    kritik3 : 

    ternary operatörü ile 

    Console.Write("kullancı adı giriniz : ");
    string? kullaniciAdi = Console.ReadLine();

    Console.Write("parola giriniz : ");
    string? parola = Console.ReadLine();

    string mesaj = (kullaniciAdi=="kullanıcı") ? "kullanıcı adı doğrulandı" : "kullanıcı adı hatalı";
    Console.WriteLine(mesaj);
    string mesaj2 = (parola=="12345") ? "parola doğrulandı" : "parola hatalı";
    Console.WriteLine(mesaj2);

    switch-case ile 

    Console.Write("kullancı adı giriniz : ");
    string? kullaniciAdi = Console.ReadLine();

    Console.Write("parola giriniz : ");
    string? parola = Console.ReadLine();

    switch (kullaniciAdi)
    {
        case "kullanıcı":
        Console.WriteLine("kullanıcı adı başarılı");
        break;
        default:
        Console.WriteLine("kullanıcı adı hatalı");
        break;
    }

    switch (parola)
    {
        case "12345":
        Console.WriteLine("kullanıcı adı başarılı");
        break;
        default:
        Console.WriteLine("kullanıcı adı hatalı");
        break;
    }

/// örnek3 : kullanıcıdan alınan 2 sayının ve yapılacak işlermin (topama  çıkarma , çarpma , bölme) seçimiyle sonucu hesaplayan console uygulamasını yazalım.

    #region if-elseif ile 
        // Console.Write("1.sayıyı giriniz : ");
        // int? sayi1 = int.Parse(Console.ReadLine());

        // Console.Write("2.sayıyı giriniz : ");
        // int? sayi2 = int.Parse(Console.ReadLine());

        // Console.Write("işlem türünü yazınız : ");
        // char islem = char.Parse(Console.ReadLine());

        // if (islem=='a')
        //     Console.WriteLine(sayi1+sayi2);
        // else if (islem=='b')
        //     Console.WriteLine(sayi1-sayi2);
        // else if(islem=='c')
        //     Console.WriteLine(sayi1/sayi2);
        // else if(islem=='d')
        //     Console.WriteLine(sayi1*sayi2);
        // else
        //     Console.WriteLine("işlem türü yanlış seçildi.");
    #endregion

    #region if yapısı ile
        Console.Write("1.sayıyı giriniz : ");
        // int? sayi1 = int.Parse(Console.ReadLine());

        // Console.Write("2.sayıyı giriniz : ");
        // int? sayi2 = int.Parse(Console.ReadLine());

        // Console.Write("işlem türünü yazınız : ");
        // char islem = char.Parse(Console.ReadLine());
        // if (islem=='a')
        //     Console.WriteLine(sayi1+sayi2);
        // else if (islem=='b')
        //     Console.WriteLine(sayi1-sayi2);
        // else if(islem=='c')
        //     Console.WriteLine(sayi1/sayi2);
        // else if(islem=='d')
        //     Console.WriteLine(sayi1*sayi2);
        // else
        //     Console.WriteLine("işlem türü yanlış seçildi.");
    #endregion

    #region switch ile
        //Console.Write("1.sayıyı giriniz : ");
        // int? sayi1 = int.Parse(Console.ReadLine());

        // Console.Write("2.sayıyı giriniz : ");
        // int? sayi2 = int.Parse(Console.ReadLine());

        // Console.Write("işlem türünü yazınız : ");
        // char islem = char.Parse(Console.ReadLine());
        // switch (islem)
        // {
        //     case 'a' :
        //     Console.WriteLine(sayi1+sayi2);
        //     break;
        //     case 'b' :
        //     Console.WriteLine(sayi1-sayi2);
        //     break;
        //     case 'c' :
        //     Console.WriteLine(sayi1*sayi2);
        //     break;
        //     case 'd' :
        //     Console.WriteLine(sayi1/sayi2);
        //     break;
        //     default:
        //     Console.WriteLine("işlem türü hatalı girildi");
        //     break;
        // }
    #endregion

    #region switc expression
        //Console.Write("1.sayıyı giriniz : ");
        // int? sayi1 = int.Parse(Console.ReadLine());

        // Console.Write("2.sayıyı giriniz : ");
        // int? sayi2 = int.Parse(Console.ReadLine());

        // Console.Write("işlem türünü yazınız : ");
        // char islem = char.Parse(Console.ReadLine());
        int? sonuc = islem switch
        {
            'a'=> sayi1+sayi2 ,
            'b'=> sayi1-sayi2 ,
            'c'=> sayi1*sayi2 ,
            'd'=> sayi1/sayi2 ,
            _ => throw new NotImplementedException(),
        };
        Console.WriteLine(sonuc);
    #endregion

    #region ternary operatörü ile
        Console.Write("1.sayıyı giriniz : ");
        int? sayi1 = int.Parse(Console.ReadLine());

        Console.Write("2.sayıyı giriniz : ");
        int? sayi2 = int.Parse(Console.ReadLine());

        Console.Write("işlem türünü yazınız : ");
        char islem = char.Parse(Console.ReadLine());

        Console.WriteLine(islem=='a' ? sayi1+sayi2:(islem=='b'? sayi1-sayi2:(islem=='c'? sayi1*sayi2:(islem=='d'?sayi1/sayi2:"işlem başarısız"))));
    #endregion

    örnek : girilen sayının değeri 10 değil ise ekrana "sayı hatalı" yazdır.

    #region if ile
        // Console.Write("lütfen bir sayı giriniz : ");
        // int? sayi1 = int.Parse(Console.ReadLine());
        // if(sayi1!=10)
        // Console.WriteLine("sayı 10 değildir.");
    #endregion

    #region ternary operatörü ile
        // Console.Write("lütfen bir sayı giriniz : ");
        // int? sayi1 = int.Parse(Console.ReadLine());
        // Console.WriteLine(sayi1==10 ? "":  "sayı 10 değildir.");
    #endregion

/// pattern machine (tasarım eşleştirmesi)

    akış kontrol mekanizmalarında yaptığımız işlemleri daha akıcı ve daha ptarik bir şekilde yapmamız için türetilen iyileştirmelerdir. 4 tip pattern vardır.

    1- type pattern
    2- constant pattern
    3- var pattern
    4- recursive pattern

/// type pattern 
    object içerisindeki bir tipin belirlenmesinde kullanılan is operatörünün desenlenmiş halidir.
    hedef : is ile belirlenen türün direkt dönüşümünü sağlar.

    örnek : eski yöntem

    object x = 123;
    if (x is string)
    {
        string xx = x as string;
        Console.WriteLine("x değeri string tiptedir.");
    }
    else(x is int)
    {
        int xx = (int)x;
        Console.WriteLine("x değeri int tiptedir.");
    }

     örnek : yeni yöntem

     object x = 123;

    if(x is string xx)
        Console.WriteLine("x değişkeni string tipindedir.");
    else (x is int aa)
        Console.WriteLine("x değişkeni int türündedir.");

    analiz : eski yöntemde x türünü if şartı ile kontrol ediyorduk, true durumunda xx değişkenine atayarak türünü kontrol altına almış oluyoruz.
    bu xx e dönüşümü is operatörü ile de olabilir , () operatörü ile de olabilir.

    type pattern ile birlikte artık bu tarz tür dönüşümü yapmaya gerek kalmıyor. if şartı içerisine yazdığımız "x is string zz" kod parçası ile 
    x değeri string ise zz olarak yoluna devam etsin demiş oluyoruz.

    object a = "sedat";
    if (a is string)
    {
        string _a  = (string)a;     // burada a değişkenini () operatörü ile unboxing ettik.
    }

    Console.WriteLine(_a);      // buradaki _a hata verdi.

    kritik : object olan a değeri string türündedir ama null da olabilme ihtimalinden dolayı if scopu dışında cast edildikten sonra değeri istediğimiz gibi kullanamayız.
    if scope ları içerisinde nullable lık aranmaz, ancak dışardan erişim istenmez ise nullable ihtimalinden dolayı kullanamayız.

/// constant pattern

    constant nedir? 
    
    Değişkenler için ram dan alan tahsis ettiğimzide hemen içini doldurmamız gerekmiyor , 
    constant tür değişkenlerde ram da alan tahsis ettiğimizde hemen içini doldurmamız ve daha sonra tekrar değiştirmememiz gerekiyor.

    constant lar sabit olduğu için sabitler ile kontrol etmek için çıkartılmış bir pattern dir. 

    object x = "ali meral";

    if ( x is "ali meral")
        Console.WriteLine("ali meral");
    else if (x is null)
        Console.WriteLine("null");

    object rakam = 123;

    if (rakam is 124)
        Console.WriteLine("rakam 124");
    else if (rakam is 123)
        Console.WriteLine("rakam 123 dür");

    kritik : is operatörünün tür kontrolü yapması standart bir davranıştır. bu pattern bize değer kontrolü de yapabilmemizi sağlar. 
    int a = 5;
    Console.WriteLine(a is int);
    Console.WriteLine(a is string);
    Console.WriteLine(a is bool);

    bunlar is operatörleri ile yapabileceğimiz standart kontrollerdir.

    Console.WriteLine(a is 5);
    Console.WriteLine(a is "5");
    Console.WriteLine(a is "abcd");
    Console.WriteLine(a is "true");

    bunlar constant pattern ile gelen özelliklerdir.

/// var pattern
    var nedir ? 
        verilen değerin türüne bürünen bir keywordu dur. bürünme işlemi runtime da yapılır.
    var pattern nedir?
        elimizdeki veriyi if sorgusu sırasında 'var' değişkeni ile elde etmemizi sağalamaktadır. 
    
    örnek :

    object x = "türkiye";

    if (x is var a)
        Console.WriteLine(a);

    type pattern in bir üstü var pattern dir.

    object x2 = "abcde";
    if(x2 is strign a2)
        Console.WriteLine(a2);
    
    burada x2 değişkenini a2 değişkeni olarak strign ture cast ettik. (type pattern kullandık)

    object x3 = "abcde";
    if(x2 is var a3)
        Console.WriteLine(a3);
    
    burada x3 türünü bilmememize gerek olmadan consolda yazdırabiliyoruz.

    önemli not: normalde var atanan değer deleme zamanında bürünürken var patterndeki var ise runtime da atandığı değere bürünür.
    
/// Recusive pattern
    switch - case yapılanmasında önceden sadece değer türlü değişkenleri kontrol edebiliyorduk ,
    ancak c# 7.0 den sonra referans türlü değişkenleri de kontrol edebiliyoruz.

    Not: recursive pattern tür kontrolü yaptığı için type pattern i kapsamaktadır.

    bu pattern switch-case yapılanmasına bir çok yenilik getirdi. 
        1- önceden sadece değer türlü değişkenleri kontrol edebiliyorken şimdi referans türlü değişkenleri üzerinde de kontrol yapabiliyoruz.
        2- önceden when şartı ile herhangi bir ikinci özellik üzerinden kontrol yapamıyorduk ancak şimdi yapabiliyoruz.
    
    type ve var pattern üzerine kritik
        type ve var patternler if koşulundan bağımsız olarakta çalışırlar.

    örnek :
    
    object x = "abc";

    bool result = x is string a;

    x string ise yola a olarak devam etsin dedik. if koşulundaki gibi nullable durumu burada da devam etmektedir.

/// C# 9.0 pattern maching enhancements
    geliştrilmiş pattern yapılarıdır.

    1- Simple type pattern
    2- Relational pattern
    3- Logical pattern
    4- not pattern

/// simple pattern
    bir değişken içerisindeki değerin belli bir türde olup olmadığının hızlı bir şekilde kontrol edilmesini sağlayan patterndir.
    daha önceki type pattern in gelişmiş halidir.

    C# 9.0 dan önce type pattern ile yapılan tür bildirimlerinin yanına değişken adı tanımlaması yahut discord ifadesinin kullanılması zorunlu idi.
    C# 9.0 dan sonra bu artık zorunlu değildir.

    örnek : eski yöntem 

    object obj = new person();

    switch (obj)
    {
        case Person p :
        //
        break;
    }

    yeni yöntem ;

    object obj = new person();

    switch (obj)
    {
        case Person :
        //
        break;
    }

    örnek2 : eski yöntem

    string GetProduct(IProduct p) => p switch
    {
        technologic _ => "teknolojik",
        Coputer_ => "bilgisayar",
        Goggles _ => "gözlük",
    };

    yeni yöntem ;

     string GetProduct(IProduct p) => p switch
    {
        technologic => "teknolojik",
        Coputer => "bilgisayar",
        Goggles => "gözlük",
    };

/// Relational pattern
    Desenlerde < , > , => , =< operatörleri kullanılabilmekte ve belirli karşılaştırmaları hızlıca gerçekleştirebilmektedir.

    Not : Switch-case özü itibari ile sadece eşitlik durumlarını kontrol edebilen bir akış kontrol mekanizması idi.
    ancak yeni gelen patternler sayesinde artık if gibi her türlü kontrol yapılabilmektedir.

    örnek :

    int number = 100;

    string result = number Switch
    {
        < 50 => "50 den küçüktür.",
        > 50 => "50 den büyüktür.",
        = 50 => "50 ye eşittir.",
        _ => "hiçbirisi",
    };

/// Logical pattern
    and , or , not gibi mantıksal operaötleri destekler.

    örnek :

     string GetProduct(IProduct p) => p switch
    {
        technologic => "teknolojik",
        Coputer and Googles => "bilgisayar",
    };

/// not pattern

    not operatörünün kullanıldığı bir patterndir.

     string GetProduct(IProduct p) => p switch
    {
        technologic => "teknolojik",
        Coputer => "bilgisayar",
        not Goggles => "gözlük",
    };

/// akış kontrol mekanizmalarından neler öğrendik.

    1- akış kontrol mekanizmaları nelerdir.
    2- switch - case yapısı
    3- when
    4- goto
    5- switch excpression (C# 8.0)
    6- switch excpression
    7- switch excpression when şartı uygulayarak
    8- Tuple pattern
    9- Tuple pattern when şartı uygulayarak
    10- Property pattern
    11- Property pattern when şartı uygulayarak
    12- Positional pattern
    13- Positional pattern when şartı uygulayarak
    14- if - else yapısı
    15- if yapısı
    16- if else if yapısı
    17- scopesuz if yapısı
    18- pattern maching (C# 7.0)
    19- type pattern
    20- Constant pattern
    21- var pattern
    22- recursive pattern
    23- pattern machine(C# 9.0)
    24- simple type pattern
    25- Relational pattern
    26- logical pattern
    27- not pattern

/// hata kontrol mekanizmaları
    biz yazılımcı içinn hata olmazsa olmazdır. hata yazılım için bir rutindir.

    bir bardağa su dökerken bile yanlışlıkla masaya/yere dökülebilir. bu çok normaldir.

    önemli olan hata yapmamak değil , hatayı yönetmektir.

    3 tür hata vardır.

    1- syntax hatalarımızın
    2- runtime hataları
    3- mantıksal hatalar

/// syntax hataları
    program diline aykırı olan hatalardır.

    örnek : string keywordu ile int türünde bir değişken tanımlamak gibi.

    özellikle gelişmiş editörler (VS gibi) sayesinde söz dizimi hataları derlemeye bile gerek bırakmakmadan yazım aşamasında uyarı vermektedir.

    hatanın bulunduğu satır derleyici tarafından rapor edildiğinden dolayı fark edilmesi ve çözülmesi en kolay hat türüdür.

/// runtime hataları
    syntax da herhangi bir hatanın olmadığı , kodun semantiğinde herhangi bir kusurun görünmediği ancak çalışma zamanında patlamaya sebep olan hatalardır.
    yazılım ayaktayken karşımıza çıkan birtakım aykırı durumlardan dolayı programın işletim sistemi tarafından kesilmesiyle / sonlandırılması ile sonuçlanır.

    çalışma zamanı hataları programın işleyişinin ortasında direkt olarak son kullanıcıya temas edebilecek hatalardır.

    hiç bir yazılımcı son kullanıcının hata ile karşılaşmasını istemez.

    böyle bir durumda çalışma zamanında alınabilecek "olası" alınabilecek hataları yönetmek ve bir şekilde manipüle etmek gerekmektedir.

    runtime hatları genelde ön mimaride tanımlı mesajları verecektir. eğer alınan hatanın ön mimaride bir karşılığı yok ise işletim sistemi dili kullanılcak
    ve daha komplex bir açıklamayla karşılaşılacaktır.

    olması gereken ise çalışma zamanı hatalarının önceden tespit ediliğ programıc tarafından daha anlaşılabilir bir şekilde düzenlenmesi gerekir.
    bunun için runtime hatlarını sağlam bir öngörü ile tespit çalışması yapılması gerekmektedir.

    runtime hatalarını önceden kestirebilemk oldukça zor olabilir. bunun için tester ler vardır.

    tüm bunlara rağmen gözden kaçan durumlar olması oldukça normaldir. dolayısıyla bir programın gelişimi sahadaki belli bir sürece bağlıdır.
    bu süreçte toplanan loglar ve son kullanıcı dönüşleri değerlendirilerek runtime hataları tespit edilerek giderilebilir.

    hata kontrol mekanizmaları neden vardır?

    runtime hatalarını kullanıcıya hissettirmeden yakalayabilmek ve ilgili hatayı manipüle edebilmek için vardır.

    önemli not: try-catch blokları sadece runtime hataları için vardır. syntax veya mantıksal hatalar için değildir.
    
/// runtime hatalarının özellikleri

    1- olmayan bir dosyayı açmaya çalışma , üzerine yazma , okumaya çalışmak
    2- olmayan değer üzerinden işlem yapmaya çalışmak
    3- uygun olmayan formatlarda çalışmak
    4- veritabanı, servis , sunucu vb bağlantılarının kopması olarak sınıflandırılabilir.

    örnek : hesap makinesi yapımında karşılabilecek runtime hatalarımızın

    Console.Write("1.sayıyı giriniz : ");
    int sayi1 = Convert.ToInt32(Console.ReadLine());
    Console.Write("2.sayıyı giriniz : ");
    int sayi2 = Convert.ToInt32(Console.ReadLine());

    Console.WriteLine("toplam : " +(sayi1+sayi2));


    sayılardan bir tanesi string olması durumunda "FormatException" hatası fırlatılır.

/// try - catch blokları
    runtime da alınan hataları manipüle etmek programlama dahilindedir.

    manipüle etmek : gelen tepkiyi istediğimiz gibi bir etkiye dönüştürebilmek demektir.

    - kullanıcıya alınan hatayı hissettirmemek,
    - alınan hatanın nedeni ile ilgili son kullanıcıyı bilgilendirmek için vardır.


    işletim sistemleri aykırı durum yaşandığında uygulamayı sonlandırmak isterler ve sonladnrırlar.
    try - catch yapılanması ile alınan hataya dair bir manipülasyon gerçekleştiriliyor ve uygulama kapanmadan yola devam etmesi sağlanıyor.

    prototip 

    try
    {
        // olası runtime hatalarına sebebiyet verebilecek kodlar buraya yazılır.
    }
    catch
    {
        // try içerisinde olası hata söz konusu ise kodun akışı orada kesilecek ve akış buradan devam edecek.
    }

    önemli not: try da hata yoksa catch çalışmaz.

    try
    {
        Console.Write("1.sayıyı giriniz : ");
        int sayi1 = Convert.ToInt32(Console.ReadLine());
        Console.Write("2.sayıyı giriniz : ");
        int sayi2 = Convert.ToInt32(Console.ReadLine());  
        Console.WriteLine("toplam : " +(sayi1+sayi2));
    }   
        catch
    {
        Console.WriteLine("hatalı değer girildi.");
    }

    kullanıcı herhangi bir değer girme aşamasında convert edilemeyen bir değer girdiğinde kodlar otomatik olarak catch bloğuna sıçrayıp oradan okumaya devam eder.

    kritik : try-catch yapılanması hatanın muhtemel olduğu kodları (try içerisindeki yapıyı) sürekli kontrol eden maliyetli bir yapıdır. bu sebepten dolayı bütün kodlar try içerisinde olmamalıdır.

/// try - catch yapılanmasındaki hata parametreleri

    runtime da alınan hataya dair bizlere bilgi veren/taşıyan parametreler vardır.

    try
    {

    }
    catch (Exception ex)    ---> buradaki Exception bizlere fırlatılacak hata ile ilgili tüm bilgileri getirecek üst türdür. bütün hataları karşılayabilen bir türdür.
    {

    }

    alınan hataya dair bilgileri edinebilmek için "ex" keywordü kullanılır. (hata , ali , ahmet , 5 gibi ifadeler de olabilir ama ex genel kullanımdır.) 
    "ex" üzerinden gerekli loglamaları vs operasyonları da yapabilmekteyiz.

    (Exception ex) yazılmak zorunda değil, yazılmadan da çalışabilir. ancak yazmak gereklidir.

    örnek : 

    try
    {
        Console.Write("1.sayıyı giriniz : ");
        int sayi1 = Convert.ToInt32(Console.ReadLine());
        Console.Write("2.sayıyı giriniz : ");
        int sayi2 = Convert.ToInt32(Console.ReadLine());  
        Console.WriteLine("toplam : " +(sayi1+sayi2));
    }   
    catch (FormatException ex)
    {
        Console.WriteLine("mesaj : " + ex.Message);
    }

    burada fırlatılan hata int ile metinsel bir ifadeyi toplamayı çalıştığı için FormatException hatası fırlatıldı.


    "ex" ile neleri bulabilir.

    1- Data             : Hatanın ek verilerini içeren bir 'IDictionary' döndürür.

    2- HelpLink         : yardım bağlantısını içeren bir 'string' döndürür.

    3- HResult          : hatanın bir tür sınıflandırması olan bir hata kodunu döndürür.

    4- InnerException   : hatanın iç içe geçmiş (inner) bir istisnasını temsil eden bir 'Exception' nesnesi döndürür.

    5- Message          : hatanın açıklamasını içeren bir 'string' döndürürür.

    6- Source           : hata oluşan uygulamanın veya nesnenin adını döndürür.

    7- StackTrace       : hatanın oluştuğu yerdeki yönetilen çağrı yığınını temsil eden bir 'string' dizini döndürür.

    8- TargetSite       : hata oluştuğu metodun bilgisini içeren 'MethodBase' türünde bir nesne döndürür.

/// runtime da alınabilecek hatalar


    // 1- ArgumentException             : Bir metodun geçersiz bir argümanla çağrılması durumunda fırlatılır.

    // 2- ArgumentNullException         : Bir metoda null bir argümanın iletilmesi durumunda fırlatılır.

    // 3- ArgumentOutOfRangeException   : Bir metodun geçerli aralık dışında bir argümanla çağrılması durumunda fırlatılır.

    // 4- DivideByZeroException         : Bir tamsayı veya ondalık sıfıra bölünmeye çalışıldığında fırlatılır.
    
    // 5- FileNotFoundException         : Var olmayan bir dosyaya erişilmeye çalışıldığında fırlatılır.
    
    // 6- FormatException               : Bir argümanın biçimi geçersiz olduğunda fırlatılır.

    // 7- IndexOutOfRangeException      : Bir dizinin veya koleksiyonun sınırları dışındaki bir indeksle erişilmeye çalışıldığında fırlatılır.

    // 8- InvalidOperationException     : Bir nesnenin uygun olmayan bir durumdayken bir metodun çağrılması durumunda fırlatılır.

    // 9- KeyNotFoundException          : Bir sözlük veya benzeri veri yapısının belirtilen anahtarı içermemesi durumunda fırlatılır.

    // 10- NotSupportedException        : Bir metodun veya işlemin desteklenmediği durumda fırlatılır.

    // 11- NullReferenceException       : Bir nesne veya null başvurusu üzerinde bir metodun çağrılması durumunda fırlatılır.

    // 12- OverflowException            : Bir aritmetik işlemin veri türünün sınırlarını aştığında fırlatılır.

    // 13- OutOfMemoryException         : Bir programın devam etmesi için yeterli belleğin olmaması durumunda fırlatılır.

    // 14- StackOverflowException       : Aşırı rekürsif işlemler nedeniyle yığın taşması durumunda fırlatılır.

    // 15- TimeoutException             : Bir işlemin zaman aşımına uğraması durumunda fırlatılır. 
                                          Yani belirli bir süre içinde tamamlanmayan bir işlem sonlandırılır ve bu istisna fırlatılır.

    sistemde tanımlanmış bir hata ile karşılaşırsak bunlardan bir tanesi fırlatılacaktır.


    Not : bütün veri türlerinin atası 'object' tir. referans türlüdür.

/// try - catch 'exception' dışında farklı bir keyword ile hata yakalama.

    try 
    {
        int s1 = 0 , s2 = 5;
        int a = s2/s1;
    }
    catch (DivideByZeroException ex)
    {
        Console.WriteLine("mesaj : "+ ex.Message)
    }

    bu örnekten yola çıkarak catch bloğunda ( ) içerisinde tanımlı olan şey 'Exception' ise yakalayacak olan tüm hatalar için (hangi tür olursa olsun) aynı çalışma yapılır,
    eğer DivideByZeroException gibi özelleştirilmiş bir exception yazılır ise sadece DivideByZeroException hatası (eğer var ise bu kısım çalışır) yakalayıp çalışma yapar.

    try - catch bloğu içerisinde bir kodun bulunması catch bloğunun çalışacağı anlamı taşımaz. bu keyword ü tetikleyecek bir hatanın oluşması gerekir. 

    catch yapılanmasında exception özelleştirilmiş ise dikkatli olunması gerekir. Farklı hata ihtimalleri var ise birden fazla catch bloğu kullanabiliriz.

/// birden fazla catch durumu

    örnek :

    try
    {
        int s1 = 0 , s2=5;
        int a = s2/s1;                       ---> burası DivideByZeroException hatası fırlatılacak.
        int b = convert.ToInt32("abcd");     ---> burası FormatException hatası fırlatılacak.
    }
    catch (exception ex)
    {
        // kodlar                            ---> her 2 durumda da aynı kod parçası çalışır. 
    }

    bu örnekte DivideByZeroException ve FormatException şeklide 2 farklı hata fırtlattı ancak catch blokları içerisinde (exception ex) yazarak genel tür sınıfı ile karşıladığımızdan dolayı 
    her 2 hataya da aynı şekilde çalışma yapar.

    örnek : olması gereken

    try
    {
        int s1 = 0 , s2=5;
        int a = s2/s1;                       
        int b = convert.ToInt32("abcd");
    }
    catch (DivideByZeroException ex)                    ---> DivideByZeroException hatası burada karşılanacak.
    {
        Console.WriteLine("mesaj : " + ex.Message);                 
    }
    catch (FormatException ex)                          ---> FormatException hatası burada karşılanacak.
    {
        Console.WriteLine("mesaj : " + ex.Message);             
    }
    catch (exception ex)                                ---> yukarıdaki hataların dışında bir hata ile karşılaşırsak emniyet olarak en sona bu kodları yazarız.
    {
        Console.WriteLine("mesaj : " + ex.Message);
    }

    try - catch yapılanmasında birden fazla catch var ise senkron bir şekilde yukarıdan aşağıya doğru bütün catch leri teker teker dolaşacaktır.
    Bu sebepten dolayı sıralama önemlidir. en sona genel hata karşılaması olan (exception ex) en sona yazılır.
    
    önemli not : Eğer en başa (exception ex) yazılırsa diğer catch lere uğramadan kod yola devam eder. 
    özelleştirilmiş catch ler için herhangi bir sıralama yoktur ancak genel hata karşılaması olan (exception ex) en sona yazılması gerekir.

/// try - catch finally bloğu
    try 
    {
        // kontrol edilecek kodlar
    }
    catch
    {
        // yukarıda hata alınan kodlara karşı davranışlar
    }
    finally
    {
        // catch bloğu çalışsa da çalışmasa da çalışacak kod blokları
    }

 Not : finally bloğu catch bloğundan sonra gelmek zorundadır.

 örnek:
 try 
    {
        // veri tabanına bağlan
    }
    catch
    {
        // isteyerek veya istemeyerek veri tabanı bağlantısı kopabilir. kopunca burada hata mesjaı göster
    }
    finally
    {
        // bağlantı kopsa da kopmasa da veri tabanı bağlantısını kes.
    }

/// try - catch yapılanmasında when yapısı ile hata filtreleme (C# 6.0)
    C# 6.0 ile birlikte hatalara when şartı ekleyerek hataları detaylı filtreleme özellikleri gelmiştir.

    try 
    {
        // kontrol edilecek kodlar
    }
    catch (exception ex) when (3==3)                                    
    {
        // yukarıda hata alınan kodlara karşı davranışlar
    }
    finally
    {
        // catch bloğu çalışsa da çalışmasa da çalışacak kod blokları
    }

    catch bloğunda düşecek bir hata oluşması durumunda catch içerisindeki kodların çalışması için when şartı eklenebilir.

    önemli not: when false döenrse catch çalışmaz.

    örnek : 
    string x = "a";
    try
    {
        int s1 = 0 , s2=5;
        int a = s2/s1;
    }
    catch(DivideByZeroException ex) when (x=="a")
    {
        Console.WriteLine("mesaj1 : " +ex.Message);
    }
     catch(DivideByZeroException ex) when (x=="b")
    {
        Console.WriteLine("mesaj2 : " +ex.Message);
    }
     catch(DivideByZeroException ex)
    {
        Console.WriteLine("mesaj3 : " +ex.Message);
    }
    catch(FormatException ex)
    {
        Console.WriteLine("mesaj : " +ex.Message);
    }
    catch (Exception ex)
    {
        Console.WriteLine("mesaj : " +ex.Message);
    }

    analiz : DivideByZeroException hatasını alacağımızı biliyorduk. when ile ilave bir şart daha ekledik. 
             when şartı true sonuç verdiği ilk catch bloğu içerisinde hata çözülür ve aynı hata türü girilen catch bloklarına uğramadan kodu devam etti.

/// mantıksal hatalar
    programın mantığında , akışında, algoritmasında, sttatejisinde bir takım şeylerin yanlış hesaplanması düşünülmesi , tasarlanması neticesinde oluşan hatalardır.

    günlük hayattaki mantıksal hataların karşılığı 'bug' dır.

    tespiti çok zor olduğu için hata türleri arasında en tehlikeli olan türdür. 

    mantıksa hatalarda bazen tek çözüm debug dur. (adım adım çözüm.)

/// Hata kontrol mekanizmalarında neler öğrendik.

    1- hata kontrol mekanizmaları nelerdir ve ne amaçla kullanılır.

    2- hata türleri nelerdir

    3- Derleme /syntax / Sözdizimi hataları

    4- runtime hataları

    5- try-catch blokları

    6- hata parametreleri

    7- hata türleri

    8- exception dışında farklı bir hata yakalama

    9- birden fazla catch bloğu

    10- finally bloğu

    11- when yapısı ile hata filtreleme (C# 6.0)

    12- mantıksal hatalar (bug - debug)

/// döngüler

    döngüler neden vardır?

    tanım : 
    tekrar eden veya tekrar etmesi gereken programları bir koşula bağlı olarak ( bir kombinasyon sürecine bağlı olarak ) 
    belirli sayıda tekrarlayabilen / işleyebilen yapılara döngü denir. 

    döngüler progmalamanın temel yapı taşlarından biridir.

    3 adaet döngü vardır.

    1- for döngüsü
    2- while döngüsü (her dilde olan döngüdür.) döngülerin atasıdır.
    3- do while döngüsü

    önemli not: foreach bir döngü değil iterasyondur.

/// neden birden fazla döngü var ?

    bir tane döngüyü bilmemiz yeterlidir. her bir döngü diğerinin yerine kullanılabilir. 
    bazı senaryolara bazı döngüler daha yatkındır.

    1- ardışık bir sayı işlemi oluyorsa 'for' döngüsü kullanılır.
    2- sonsuz bir döngü var ise 'while' döngüsü kullanılır.
    3- manevratik yapılarda 'do-while' döngüsü kullanılır.

/// for döngüsü

    genellikle ardışık durumlarda kullanılan bir döngüdür. 

    yapısı:

    for ( I ; II ; III)
    {
        // kodlar
    }

    I : genellikle başlangıç değeri burada tanımlanır. bu değer dışarda tanımlanarak bu kısım boş da geçilebilir.
        ardışık işlemlere başlayabilmek için bir ilk değere ihityacımız vardır. 

    II : bu kısımda boolean türünde değer dönen ve true olduğu sürece döngünün tekrar edeceği 'şart' kısmı yazılır.
        değişkenden bağımsız herhangi bir şart/koşul ifadesi tanımlanabilir.

    III : genellikle başlangıç değerinin arttırma ve azaltma durumlarının gösterildiği yerdir. döngü içerisinde de gösterilebilir olduğundan dolayı bu kısım da burada boş geçilebilir.
        değişkene bağlı olmak zorunda değildir.

/// for döngüsü akışı

    1.adım : for keywordunu gören compiler döngü olacağını anladı ve içeri girdi.
    2.adım : eğer değişken tanımlama işlemi var ise bu işlemi yapacak ve ram da ilgili türde alan tahsis ederek içeriye değişken atamasını yapacaktır.
        not : eğer değişken dışarda tanımlandıysa (ki bu ihtimal de var) burada başlangıç değeri almak zorundadır. 
    3.adım : Copiler koşuk kısmına geldi ve koşulu kontrol ediyor. eğer true ise kodları çalıştıracak değil ise döngüden çıkacak.
    4.adım : döngüden çıkamyıp kodları çalıştırır ise arttırma/azaltma kısmına gidecek ve oradaki adımı gerçekleştirecek.
    5.adım : arttırma / azaltma işlei yaptıktan sonra true / false durumunu kontrol edecek ve true ise kodları tekrar çalıştıracak.
    .
    .
    son adım : arttırma / azaltma kısmına giren compiler burada işini bitirdikten sonra true / false durumunu kontrol edecek. false durumu olursa for döngüsünden çıkarak yoluna devam edecek.

/// örnek : 5 defa ekrana A değerini yazdıralım

    for (int i = 0 ; i < 5 ; i++)
        Console.WriteLine("A");
    
/// örnek : 1 den 10 a kadar olan sayıları alt alta ekrana yazdıralım.

    for (int i = 1; i < 11 ; i++)
        Console.WriteLine(i);

/// örnek : 1 ile 40 arasındaki çift sayıları toplayarak sonucu ekrana yazdıralım.

    int toplam = 0;
    for (int i = 0; i < 41; i++)
    {
        if(i%2 ==0)
            toplam += i;
        
    }
    Console.WriteLine("toplam: " +toplam );

/// örnek : klavyeden girilen sayının faktöriyelini hesaplayıp ekrana yazdıralım.

    Console.Write("Lütfen bir sayı giriniz : ");
    int sayi = Convert.ToInt32(Console.ReadLine());
    int fakt = 1;

    for (int i = 1; i <= sayi ; i++)
    {
        fakt *=i;
    }
    Console.WriteLine("faktöriyel : " + fakt);

/// for döngüsü kritik - 1 / klasik for gösterimi

    for (int i = 1; i <= 6 ; i++)
    {
    // kodlar
    }

/// for döngüsü kritik - 2  / başlangıç değerini dışarda verebiliriz.
    int i = 1

    for (; i <= 6 ; i++)
    {
    // kodlar
    }

/// for döngüsü kritik - 3 / başlangıç değerini dışarda verip içeride başka bir başlangıç değeri ile ezebiliriz.
    int i = 1

    for (i = 5; i <= 6 ; i++)
    {
    // kodlar
    }
    
/// for döngüsü kritik - 4  / arttırma / azaltma işlemini döngü içerisinde herhangi bir yerde yapabiliriz. ( dikkatlı olmak gerekir.)

     for (int i = 1; i <= 6 ; )
    {
    // kodlar
    i++;
    }

/// for döngüsü kritik - 5 / şart başlangıç değerina bağlı olmak zorunda değil.

    int a = 9
    for (int i = 1; a <= 6 ; i++)
    {
    // kodlar
    }

/// for döngüsü kritik - 6 / başlangıç , şart , arttırma / azaltma olmadan da for döngüsü yapılabilir (başlangıç , arttırme veya şart olmadığınnda dolayı sonsuz döngü olur).
    
    for (; ;)
        {
        // kodlar
        }

/// for döngüsü kritik - 7 / şart olmadığından dolayı sonsuza kadar kodlar tetiklenecektir.
    
    for (int i = 0 ;   ; i++) 
        {
        // kodlar
        }

/// for döngüsü kritik - 8 / birden fazla değişken tanımlayarak for döngüsü kurulabilir.
    
    for (int i = 0 , j = 10 ; i<10, j<0  ; i++ , j--) 
        {
        // kodlar
        }

    burada tanımlanan her 2 değişken için de şart ve arttıma / azaltma yapılabilir.

/// while döngüsü

    prototip 

    int i = 0;
    while( şart )
    {
        // kodlar
        i++;
    }

    while döngüsü şart =true olduğu sürece tetiklenir.

    for dönügüsüne kıyasla daha ilkel bir döngüdür , programlamanın ilk tasrlanan döngüsüdür.

    while döngüsü bütün dillerde vardır.

    genellikler süreci bilinmeyen / sonsuz döngü oluşacak durumlarda kullanılır.

/// while döngüsü ile for döngüsü kıyaslamak

     for (int i = 1; i <= 6 ; i++)
    {
    // kodlar
    }

        int i = 0;          ---> for döngüsü I.kısım
    while( şart )           ---> for döngüsü II.kısım
    {
        // kodlar
        i++;                ---> for döngüsü III.kısım
    }

/// örnek ekrana 10 defa "merhaba dünya" yazalım.

    int i = 0;

    while (i <10)
    {
        Console.WriteLine("Merhaba Dünya");
    }

/// Örnek : klavyeden girilen sayıdan geriye doğru 0'a kadar sayan bir sayaç hazırlayalım.

    Console.Write("lütfen bir sayı giriniz : ");

    int i = Convert.ToInt32(Console.ReadLine());

    while (i > 0)
    {
        Console.WriteLine(i);
        i--;
    }

/// Örnek : 0 ile 100 arasındaki tek sayıları toplayarak sonucu ekrana bastıralım.

    int i = 0 , toplam = 0;

    while (i<=100)
    {
        if (i % 2 ==0)
        {
            toplam +=i;
        }
        i++;
    }
    Console.WriteLine("tek sayıların toplamı : " + toplam);

/// Örnek : klavyeden girilen sayının faktörüyelini bulalım.    

    Console.Write("lütfen bir sayı giriniz : ");
    int i = Convert.ToInt32(Console.ReadLine());
    int faktoriyel = 1;
    while (i>0)
    {
        faktoriyel *=i;
        i--;
    }
    Console.WriteLine("Girilen Değerin Faktöriyeli : " + faktoriyel);

/// Örnek : O anki tarihin saniye değeri 5in katı ise tarhini ekrana bastıralım.

    while (true)
    {
        if (DateTime.Now.Second % 5 == 0)
            Console.WriteLine(DateTime.Now);
    }

/// do-while döngüsü :

    prototip 

    do 
    {

    } while(true)

    not : while ile do-while arasındaki fark ,
            while önce şarta bakar ve sonra kodu çalıştırır.
            do-while ise hera halukarda bir defa kodu çalıştırır ve sonra şartı kontrol eder.

    hangi durum olursa olsun kodu while döngüsü ile çalıştırıyorsak döngü içerisindeki kodların hiç tetiklenmeme ihtimali var, do - while döngüsü ile çalıştırıyorsak döngü içerisindeki kodların minimum 1 kere çalışır.

    while döngüsü önce havaya bakıp sonra şemsiyeyi almak, do-while döngüsü önce şemsiyeyi almak sonra havaya bakmak gibidir.

   birden fazla veri tabanı sorgusu çalıştırılacaksa bu sorguları tek tek string olarak yazarız ve do - while ile işleme sokarız. 1.sorgu her halukarda çalışır, 2.sorgu varsa çalışır , 3.sorgu varsa çalışır...

/// do - while ile while döngüsü kıyaslamak

    while döngüsü : 

    while(true)
    {
        // kodlar
    }

    do-while döngüsü :

    do
    {
        // kodlar
    } while(true)

///  scopesuz döngüler
    tek satırlık kodlar çalışıtırlacaksa scope kullanmaya gerek yoktur.

    for (int i = 0; i < 10; i++)
    Console.WriteLine("a");

    while (true)
        Console.WriteLine("b");

    do Console.WriteLine("c");  while (true);

/// sonsuz döngüler

    şart koşulunun sonsuza kadar sağlanması durumunda oluşan döngü hareketi sonsuz döngü olarak isimlendirilir. bazı durumlarda bilerek bazı durumlarda istemeden sonsuz döngü meydana gelebilir.

    istisna :

    for (int i = 0; true ; i++)
    {
        // kodlar
    }

    bu döngü aslında sonsuz bir döngü değildir. çünkü i++ ile i değerini 1er arttırma komutu verdik, bu arttırma int sınırına ulaşana kadar tetiklenecektir.

    for (; true ; ) ---> sonsuz döngü
    {
        // kodlar
    }

    for ( ; ; )     ---> sonsuz döngü
    {
        // kodlar
    }

    bilinçli sonsuz döngü neden kullanılır.

    - örnek 1 : Bir internet sitesi üzerinden satışa çıakcak bi bir bileti almanız gerek ve ne zaman satışa çıkacağını bilemiyoruz.
                bu tür durumlarda bilinçi sonsuz döngü kullanılabilir.

    - örnek 2 : herhangi bir düğmeye tıklandığında bir işlem yapmamız gerekiyor ancak düğmeye ne zaman basılacağını bilmiyoruz diyelim.
                bu tür durumlarda da bilinçli sonsuz döngü kullanılabilir.

    bilinçli sonsuz döngüden nasıl çıkabiliriz.
    
    / for döngüsü ile 

    bool dongu = true;

    for( ; true ; )
    {
        if(true)
            dongu !=dongu;
    }

    / while döngüsü ile 

    bool durum = true;

    while(true)
    {
        if (true)
            durum !=durum
    }

    not : fıtrat olarak while döngüleri sonsuz döngülere daha yatkındırlar.

    / do - while döngüsü ile 

    bool durum = true;

    do 
    {
        if (true)
            durum !=durum
    }
    while(durum)

/// iç içe döngüler

    kendi içinden olsun veya olmasın bir döngü içerisinde farklı bir döngü başlatabiliriz.

    not : döngüler maliyetlidir. iç içe döngüler daha da maliyetlidir.

    for ile iç içe döngü yapma : 

    for (int i = 0; i < length; i++)            ---> burada i değişken ismini kullandığımız için bu scope içerisinde herhangi bir yerde başka bir i değişken ismi olamaz.
    {
        for (int j = 0; j < length; j++)
        {
            for (int k = 0; k < length; k++)
            {
                // kodlar
            }
        }
    }

/// foreach bir döngü müdür ? 

    iterasyon : bir sornaki veriyi getirebileceğimiz yapılanmalardır. kombinasyon veya şart yoktur. iterasyonda bir veri kümesi olması gerekmektedir.

    döngülerde başlangıç ve bitiş değerlerini kendimiz belirleyebilriz ancak iterasyon veri kümesinin 1.elemanı ile başlayıp son elemanına kadar gitmesi gerekir. yarıda kesilemez.


    önemli not : her döngü olabilen yapı döngü değildir.

/// döngülerde neler öğrendik.

    1- döngü nedir?

    2- hangi döngü nereye yakışır.

    3- for döngüsü 

    4- while döngüsü 

    5- do while döngüsü

/// keyword nedir ? kodlamaya kullanılan başlıca keywordler.

    keyword : derleyici için daha önceden tnaımlanmış ve özel anlamlara sahip olan anahtar sözcüklerdir. berlili opersayonları sağlamamızı sağlar.

    başılca keywordler : 

    abstract
    asbase
    bool
    add
    alias
    ascending
    break
    byte
    case
    catch
    async
    await
    by
    char
    checked
    class
    cont
    descendinng
    dynamic
    Equals
    continue
    decimal
    default
    delegate
    from
    get
    global
    do
    double
    else
    enum
    group
    Into
    join
    event
    explicit
    extern
    false
    let
    nameof
    notnull
    finally
    fixed
    float
    for
    on
    orderby
    partial (type)
    foreach
    goto
    if
    implicit
    partial(method)
    rename
    Select
    in
    int
    interface
    internal
    Set
    unmanaged (generic type constraint)
    value
    is
    lock
    long
    namespace
    var
    when(filter condition)
    where(generic type constraint)
    new
    null
    object
    operatör.
    where (query clause)
    width
    yield.
    out.
    override.
    params.
    private.
    protected
    public.
    readonly.
    ref.
    return
    sbyte.
    sealed
    short.
    sizeof
    stackalloc
    static
    string
    struct
    switch
    this.
    throw.
    true.
    try.
    typeof
    unit.
    ulong
    unchecked
    unsafe
    ushort
    using
    virtual
    void
    volatile
    while

/// keywordler

    keywordler proglamanın atomik parçalarıdır. derleyici için ön tanımlı olan nerede hangi amaca hizmet edeceği belli olan ve kod içerisinde hangi nokalardan çağırılabileceği
    kurallar ile sınırlandırılmış olan anahtar sözcüklerdir.

    operatörler ile keywordler arasındaki fark nedir ?

    operatör : esas olarak belirli bir operasyonu / eylemi üstlenen yapılardır.

    keywordler : operatörlerden daha geniş kapsamlıdır.

    her operatör aynı zamanda bir keyworddür ancak her keyword operatör olmayabilir.

/// konseptli ve konseptsiz keywordler

    konsepli keywordler : tek başlarına kullanılamayan , ve bir konsepte bağlı olarak kullanılan keywordlerdir. ( namespace , class , for , while , do , int , short ...)
    genel itibair ile keywordler konseptlidir. konseptsiz keyword sayısı çok azdır.

    konseptsiz keywordler : yapısal olarak tek başına kullanılabilen ve bir konsepte bağlı olmayan keywordlerdir. ( return , break , continue , goto)

/// Yardımcı manevratik komutlar

    oluşturduğumuz algoritme (döngü , metot vs gayet güzel çalışıyor) ancak ihtiyaca binaen herhangi bir zaman diliminde bunu kesmek veya döngüden çıkmamız gerekebilir.
    

    1- döngü tamamlanmadan herhangi bir çalışma anında istediğimiz değere ulaştığında vs çıkmamız gerekebilir , 
    2- döngü devam ederken bazı adımları atlamamız ama döngüye devam da etmemiz gerekebilir , 
    3- çalışan veya çalışmaya devam edecek olan döngüyü sonlandırmak gerekebilir.

    bunu gibi durumlarda manevratik komutlar yardımcı olurlar.

    yardımcı manevratik komutlar olmadan da sonuca ulaşabiliriz ancak uzun ve yorucu olabilir.
    daha efektif kod yazmak ve yeniliklere açık olmak adına manevratik koutları kullanmak gerekir.

    manevratik komutlar bize yapamacağımız şeyleri yapmamızı sağlamazlar , mevcutta yapılabilir olan bir şeyi daha efektif yapmamızı sağlarlar.

    manevratik komut kullanmadan for döngüsünden çıkma : 

    for (int i = 0; i<10;i++)
    {
        if(i ==5)
        {
            i=10;
        }
    }

    analiz : for döngüsünde i nin değeri 5 olunca if true olacak ve ekrana i=10 yazılarak döngü sonlandırılmış olacak.

    manevratik komutlar ;

    1- break,
    2- continue,
    3- return,
    4- goto,

/// 1- break keywordu : 

    kullanıldığı yerler : 

    1- switch case yapılanması içerisinde kullanılır ,
    2- döngülerde( for , while , do while ) kullanılır.
    3- foreach iterasyonlarında,


    1- switch örnek : 


        switch (16)
    {
        case 5 :
        Console.WriteLine("değer 5");
        break;
        case 10:
        Console.WriteLine("değer 10");
        break;
        default:
        Console.WriteLine("değeri bilemedik.");
        break;
    }

    Önemli not : break kullanıldığı scope dan dışarı çıkmayı sağlar. 

    örnek : 

        for (int i = 0; i < 5; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            if(j==1)
                break;

            Console.WriteLine("i : " + i + " j : " + j );
        }
    }

    burada kullanılan break j nin olduğu for döngüsünden çıktı , i nin olduğu döngü görevini tamamladı.

    örnek1 : kullanıcıdan "t" harfi girilene kadar alınan sınırsız sayıda sayıyı toplayan ve sonucu ekrana yazdıran uygulamayı yazalım.

    int toplam = 0;
    while(true)
    {
        Console.Write("Lütfen bir sayı giriniz : ");
        string girilenDeger = Console.ReadLine();
        if (girilenDeger =="t")
            break;
        else
        toplam += Convert.ToInt32(girilenDeger);
    }
    Console.WriteLine("toplam : " + toplam);

    Örnek2 : kullancıdan alınan sonsuz adet sayı değerlerinin 37nin katı girildiğinde sonlanan uygulamayı yazalım.

    
    while(true)
    {
        Console.Write("lütfen sayı giriniz : ");
        int sayi = Convert.ToInt32(Console.ReadLine());
        if (sayi %37 ==0)
        {
            Console.WriteLine("37 nin katı değer girdiğiniz için uygulama sonlandırıldı.");
            break;

        }
    }

/// Continue keywordu

    kullanıldığı yerler : 

    1- bütün döngüler,

    kullanım amacı : 

    döngülerde bazen yapmış olduğumuz kombinasyona göre elde ettiğimiz değerlerden kullanmak istemediklerimiz olabilir.
    bu kullanmak istemediğimiz değerleri kullanmadan ama döngüden de çıkmadan kodun akmaya devam etmesini sağlar.

    o anki turu es geçip bir sonraki turdan devam eder.

    önemli not: continue keywordunden sonraki kodlar derlenmezler. compiler döngünün başına geri döner.

    örnek : 1 den 10 a kadar olan tek sayıları ekrana yazdıralım.

        for (int i = 0; i < 10; i++)
    {
        if (i%2==0)
            continue;
        Console.WriteLine(i);
    }

    örnek2 : kullanıcın girdiği sonsuz adet sayıdan pozitif olanları çarpan ve "ç" tuşuna basıldığında sonucu ekrana bastıran bir uygulama yapalım.

    int carpim = 1;
        int sayi;
        while(true)
        {
            Console.Write("Lütfen bir sayı giriniz : ");
            string girilenDeger = Console.ReadLine();
            if (girilenDeger == "ç")
            {
                Console.WriteLine("Girilen Değerlerin Çarpımı : " + carpim);
                break;
            }
            
            else
            {
                sayi = Convert.ToInt32(girilenDeger);
                if (sayi < 0)
                    continue;
                carpim *=sayi;
            } 
        }
    örnek3: 1 ile 100 arasındaki 7 nin katı olmayan sayıları ekrana yazdıralım.

        for(int i = 0; i <101 ; i++)
    {
        if(i%7==0)
            continue;
        Console.WriteLine(i);
    }

/// return keywordu 

   kullanıldığı yerler : 

    1- method içerisinde her yerde kullanılabilir.

    kullanım amacı : 

    nerede çağırılırsa çağırılsın bulunduğu metottan çıkış yapar/ metodu sonlandırır.
    ileride göreceğimiz metotlar konusunda geriye değer döndürme sorumluluğunu da üstlenen bir keyworddür.

    main
    {
        for
        {
            while()
            {
                if()
                return ;                ---> complier for döngüsünün de dışına çıkar.
            }
        }
        compiler buradan koda devam eder.
    }

/// goto keywordu

    nedir? = kodun senkronzasyonunu değiştiren, akışın referans olarak işaretlenen alana geri dönmesini sağlayan bir keyworddür.

    kullanıldığı yerler : 

    1- switch case yapılanmasında dahili olarak kullanılabilir.
    2- metot içerisinde herhangi bir yerde kullanılabilir.

    kullanım amacı : 

    davranışsal olarak döngülere benzerler.

    a:
    .
    .
    .
    .
    goto a; ---> compiler 3977.satıra geri döner. tekrar bu satıra gelince tekrar 3977.satıra geri döner. sonsuz döngü olabilir.

    switch case yapılanmasında herhangi bir case e yönelim yapılabilir, kendinden önceki olmak zorunda değildir. 

    teknik olarak programı yavaşlattığı söylenmekte olup daha maliyetlidir. pek tavsiye edilmez.

    örnek:

    1 den 100 e kdaar goto keywordu kullanarak sayalım.

    int i =0;
    a:
    Console.WriteLine(i++);
    if(i!=101)
        goto a;


    kritik 1 : goto keywordu tanımlanan referansa gideken scope lar dikkate almaz. (main metotu içerisinde olduğu sürece)

    scope lar dışına çıkabiliyor olması onun kritik öneme sahip olduğu anlamına gelir.

/// manevratik keywordlerde neler öğrendik.

    manevratik keyword neden vardır?

    kodun akışına müdahale etmeden araya keywordler ekleyerek akışı değiştirebiliyoruz. 

    break , döngüyü kırmaya yarar.
    continue, döngüde adım atlamaya yarar.
    return, döngüyü sonlandırmaya yarar.
    goto, referasn olarak işaretlenen bir noktaya geri dönerek sonsuz döngü yapmaya yarar.

/// ekstra bilgi ,

    döngülerde boş scope yerine ";" operatörü ile daha temiz kod yazabiliriz. asenkron programlamada içi boş sonsuz döngülere ihtiyacımız olabilir.

    while(true)
    {
                            
    }

    yerine : 

    while(true);

    for(;;)
    {

    }
    yerine :

    for(;;);

    do
    {
        
    } while (true);

    yerine :

    do;
    while(true);


    if(true)
    {

    }
    yerine :

    if(true);

    kullanılabilir.

// diziler 

    bir sınıf dolusu öğrncinin yaşları ile ilgili bir işlem yapmak istediğimizi düşünelim.

    dizileri kullanamdan bu yaş verilerini şu şekilde saklayabilirdik,

    int ogrenciYasi1 = 23;
    int ogrenciYasi2 = 21;
    int OgrenciYasi3 = 22;
    .
    .
    .
    int ogrenciYasi30 = 22;

    not : eğer programlamada " aynı türde" birden fazla değer varsa bunları 2 şekilde tutabiliriz.

        1- her bir değeri farklı bi değişkene atarat (yukard yaptığımız gibi zor yöntem)
        2- tek bir değişken altında veri kümsei olarak ( dizi )

    diziler nedir ? 

    tek bir değişken altında birden fazla aynı türde değeri basındırmamızı sağlayan veri kümesine dizi denir.

    birden fazla farklı türde veri tutamazlar.

    diziler veri kümeleri oldukları için , içlerindeki birden fazla veri üzerinde kümesel işlemler yapmamızı sağlayabilirler.

    diziler prosedürel programlamanın temel yapıtaşları oldukları için daha gelişmiş yapılar ve koleksiyonların da temelini teşkil etmektedirler ve gelişmelerine katkıda bulunmaktadırlar.

    dizilerde bazı sınırlamalar mevcuttur. bu sınırlamalar (önceden eleman sayısının bilinmesi , çalışrıken index lere dikkat etmek gibi) koleksiyon yapılarının icad olmasına yol açmıştır.

    1- diziler referanas türlü değerlerdir
    2- diziler nesnel yapılardır
    3- diziler özelinde class dırlar.

    yapısal olarak Ram de "heap" alanında tutulurlar.

    diziler referans türlü yapılardır dedik ancak referans türlü değişkenleri de değer türlü değişkenleri de içlerine alabilirler.

    bir dizi sade ve sadece "tek bir türde değer alabilir." eğer dizi int türünde tanımlanmış ise int türü dışında değer alamaz
    var keywordu ile tanımlandıysa aynı türde veri barındırmak zorundadır.
    farklı türde veriler saklamak gerekiyor ise diziyi "object" türünde oluşturmak gerekir.

// yazılımda veri kümeleri neden vardır ? 

    verile üzerinde kimi zaman istatistiksel hesaplamalar , kimi zaman başka çalışmalar yapmak isteriz. bu çalışmaya dahil olacak verileri bir küme halinde tutabilirsek daha efektif çalışma yapabiliriz.
    bu sebeple veri kümeleri icad edilmiştir.

    dizi kavramı yazılıma "index" kavramını getirmiştir. 

// index kavramı nedir?

    bir çöp kutusuna rastgele attığımız çöpler ortamı karmaşıklaştırır.
    dizilerin icad edilmesindeki amaç birden fazla veri ile eşzamanlı olarak çalışma yapmak , ihtiva edilen veriler üzerinden çalışma yapmak olduğundan dolayı
    elimizdeki veri kümseine net bir hakimiyet kurmamız gerekir. ( kaç eleman var , hangi eleman nerde durur gibi)
    çünkü biz bu veri kümesi üzerinde daha sonra verileri değiştirebiliriz, veriler üzerinde işlemler yapabiliriz.
    bu sebepten dolayı fişleme dediğimiz icad devreye giriyor ve her elemana benzersiz bir numara veriliyor. bu numaraya index numarası denir.

    index 0 dan başlar ve sistem otomatik olarak 1-2-3-4.. diye devam eder.

// dizi prototipi

    int a ;     ---> bu bir a isiminde ve int türünde bir değişken

    int[] a;    ---> bu bir a isminde ve int türünde bir dizi dir. 

    type[] name = mew int[eleman sayısı] ;      ---> temel dizi tanımlama formatı.

// dizi tanımlarken dikkat edilecekler,

    1- dizinin türü
        eşitliğin her iki tarafında da aynı türde olmak zorundadır.
        int[] name = new string[]  ---> Olmaz.
        string[] name = new string[] ---> olur
    2- dizinin eleman sayısı
        string[] name = new string[] ---> olmaz.
        string[] name = new string[7] ---> olur.
    3- dizinin ismi
        string[] = new string[7] ---> olmaz.
        string[] name = new string[7] ---> olur.

    olmazsa bir dizi tanımlanamaz.

    yazılım demek verilerin işlenmesi demektir , basit bir veriyi basit bir değişkende tutabiliriz ve bu değişkekn üzerinden işlemler yapabiliriz.
    milyon tane veri var ise , bu milyon tane veriyi nasıl tutup nasıl saklayacağız ? saklamak için daha komplex yapılara ihtiyaç vardır

    dizi - koleksşyon - object ..... (basitten komplexe) 

    RAM Bellekte 2 alan vardır.

    stack : 

        değişkenin türü,
        değişkenin değeri,
        referansın türü , 

    tutulur.

    heap :
        
        referansın değeri 

    tutulur.

    bir dizi tanımlandığı an (kullanılsın veya kullanılmasın) eleman sayısı kadar RAM de alan tahsisi yapılır , indexlenir ve default değerler atanır.
    biz diziye eleman ataması yaparken default değerleri ezerek yaparız.

    default değerler,

        - int : 0,
        - string : null,
        - bool : false,
        - char : /0

// tanımlanmış bir diziye değer atama

    int[] name = new int[3];        ---> int türinde name adında ve 3 elemanlı bir dizi oluşturduk. tam bu esnada index numaraları ve default değerleri atandı.

    name[1] = 3;        ---> default olarak 0 atanan 1.indexteki elemanın değerini 3 olarak ezdik.


    not : dizinin içerisindeki elemanlara değer ataması yapılırken değişken davranışı gösterirler. (ezilebilirler)
    not2: dizilerde sıralı tanılmaya yapmak zorunda değiliz ,hangi elemanda değişiklik yapcağımızı yazdığımız için herhangi bir sıra takip etmemiz gerekmiyor.
    not3: dizi sınırlarını aşan (yukarıdaki dizide 4.elemana değer atamaya çalışırsak ) runtime de hata alırız ve program sonlandırılır.
    not4: türüne uygun değer ataması yapmamız gerekir. int türünde tanımlanmış bir dizi için bool türünde değer veremeyiz.

// tanımlanmış bir diziden değer okuma 

    int[] name = new int[3]; 
    Console.WriteLine(name[2]);         ---> 2.indexteki elemanı ekrana bastırır , eğer tanımlama yapılmadıysa dafault olarak 0 döner.

// diziler içinde döngü ile dönme 
 
    string[] personeller = new string[5];
    personeller[0] = "hilmi";
    personeller[1] = "hüseyin";
    personeller[2] = "rıfki";
    personeller[3] = "şuayip";
    personeller[4] = "naci";

    for (int i = 0 ; i < personeller.length;i++)
        Console.WriteLine(i);                           ----> personel sayısı kadar i değeri döner. 0-1-2-3-4 

    for (int i = 0 ; i < personeller.length;i++)
        Console.WriteLine(personeller[i]);              ----> personeler isimlerini döner. hilmi-hüseyin-rıfkı-şuayip-naci

    diziler genellikle döngüler ile birlikte kullanılır. (hangi döngü ile kullanıldığı tercih sebebidir. bütün döngüler ile kullanılabilir.)

// dizilerdeki sınırlılıklar

    1- eleman sayısını vermek zorunda olmak
    2- kullansak da kullanmasak da alan tahsisi gerçekleşmiş olması
    3- eleman sayısının sınırlı olması IndexOutOfRangeException hatasına sebep olabilir
    4- index üzerinden değer ataması yapıldığından dolayı karışıklığa yol açabilir.

    bu kadar sınırlılık olmasına rağmen neden dizileri kullanıyoruz ?

    hızlı ve kullanışlı olduğundan dolayı

// dizi tanımlama varyasyonları

    varyasyon - 1

        tanımlama : 

        int[] number = new int[5];

        yazma : 

        number[3]; 100;

        okuma : 

        Console.WriteLine(number[3]);       ---> // 100

    varyasyon - 2

        int[] number = {30,24,32,55}
        string[] isimler = {"ali" ,"veli","can","cem"}


    varyasyon - 3

        int[] number = new int[] {30,24,32,55}
        string[] isimler = new stirng[] {"ali" ,"veli","can","cem"}
    
    varyasyon - 4

        int[] number = new int[4] {30,24,32,55}
        string[] isimler = new stirng[4] {"ali" ,"veli","can","cem"}

    varyasyon - 5

        object[] number = new[] {30,24,32,55}
        object[] isimler = new[] {"ali" ,"veli","can","cem"}

/// Array sınıfı nedir?

    dizi denince Array sınıfı , Array sınıfı denince akla dizi gelmelidir.

    Not : referans türlü değişkenler sınıflardan türeyen nesnelerdir.


bugün yazılım için bir dönüm noktasıdır. 24.04.2024
.